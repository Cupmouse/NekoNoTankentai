<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Nekonium Block Explorer</title>
    <link rel="stylesheet" href="/css/pure-min.css">
    <link rel="stylesheet" href="/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="icon" type="image/png" href="/adventure_flag_16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="/adventure_flag_32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/adventure_flag_256.png" sizes="256x256">
    <script type="application/javascript" src="/js/Chart.min.js"></script>
    <script type="application/javascript" src="/js/bignumber.min.js"></script>
    <script type="application/javascript" src="/js/blockies.min.js"></script>
</head>
<body>
<header>
    <div class="pure-g">
        <div class="pure-u-3-4">
            <a id="title" href="/">üö©„Å≠„Åì„ÅÆÊé¢Ê§úÈöä</a>

            <div id="menu" class="pure-menu pure-menu-horizontal">
            <nav>
                <ul class="pure-menu-list">
                    <li class="pure-menu-item">
                        <a href="/blocks/1" class="pure-menu-link"><i class="fa fa-th-large" aria-hidden="true"></i> Blocks</a>
                    </li>
                    <li class="pure-menu-item">
                        <a href="/transactions/1" class="pure-menu-link"><i class="fa fa-exchange" aria-hidden="true"></i> Transactions</a>
                    </li>
                    <li class="pure-menu-item pure-menu-disabled">
                        <i class="fa fa-bar-chart" aria-hidden="true"></i> Statistics
                    </li>
                </ul>
            </nav>
            </div>
        </div>
        <div class="pure-u-1-4">
            <div id="mini-statistics" class="pure-g text-selectable">
                <div class="pure-u-1-3">
                    # 1000000
                </div>
                <div class="pure-u-1-3">
                    Diff 150T
                </div>
                <div class="pure-u-1-3">
                    ¬• 1000
                </div>
            </div>
        </div>
        <div class="pure-u-1">
            <form id="search-form" class="pure-form">
                <input type="text" id="search-box" class="pure-input-1" placeholder="Search">
            </form>
            <div id="search-suggestions">
                <ul id="search-suggestion-list">
                </ul>
            </div>
        </div>
    </div>
</header>
<div id="contents-wrapper">
    <!-- Loading screen appears only on view loading -->
    <div id="loading">
        LOADING...
    </div>
    <!-- Inserts an contents in this div tag using Ajax -->
    <div id="contents">


    </div>
</div>

<script type="application/javascript">
    /* Common Declaration Start */
    const SITE_TITLE = 'Neko no Tankentai';

    const div_contents = document.getElementById('contents');
    const search_box = document.getElementById('search-box');
    const search_suggestions = document.getElementById('search-suggestion-list');

    // Type check

    const REGEX_ADDRESS = /^0x[0-9a-fA-F]{40}$/;
    const REGEX_HASH64 = /^0x[0-9a-fA-F]{64}$/;
    const REGEX_NON_NEGATIVE_INT = /^[1-9]+\d*$/;

    const isBlockHash = (hash) => {
        return REGEX_HASH64.test(hash);
    };

    const isTxHash = (hash) => {
        return REGEX_HASH64.test(hash);
    };

    const isAddressHash = (hash) => {
        return REGEX_ADDRESS.test(hash);
    };

    const isNonNegativeInt = (str) => {
        return REGEX_NON_NEGATIVE_INT.test(str);
    };

    // UI and human friendly values

    const ONE_NUKO = new BigNumber(10).pow(18);
    const DIFF_PREFIXES = ['', 'K', 'M', 'G', 'T', 'P', 'E'];

    const generatePagination = (id, buttonLimit, pageNumber, lastPageNumber, linkSupplier) => {
        let htmlPag;

        if (id === null) {
            // No id
            htmlPag = '<div class="pagination">';
        } else {
            htmlPag = `<div id="${id}" class="pagination">`
        }

        if (pageNumber === 1) {
            // Previous button is disabled
            htmlPag += `<span>&lt;&lt;</span><span>&lt;</span>`;
        } else {
            htmlPag += `<a href="${linkSupplier(1)}">&lt;&lt;</a><a href="${linkSupplier(pageNumber - 1)}">&lt;</a>`;
        }

        // Calculates where page to start

        let pageStart;

        // Can selected page button be centered?
        if (lastPageNumber > buttonLimit) {
            if (pageNumber - (buttonLimit / 2) < 1) {
                // Don't have enough space left side, start from 1
                pageStart = 1;
            } else if (pageNumber + (buttonLimit / 2) > lastPageNumber) {
                // Don't have enough space right side
                pageStart = lastPageNumber - buttonLimit + 1;
            } else {
                // Have space for both side
                pageStart = pageNumber - Math.floor((buttonLimit / 2));
            }
        } else {
            // Can show all of page buttons
            pageStart = 1;
        }

        // Generate an button for each page
        let i = pageStart;

        for (; (i < pageStart + buttonLimit) && (i <= lastPageNumber); i++) {
            // Selected button will be shown differently
            if (i === pageNumber) {
                htmlPag += `<span class="pagination-element-selected">${i}</span>`;
            } else {
                htmlPag += `<a href="${linkSupplier(i)}">${i}</a>`;
            }
        }

        if (i <= lastPageNumber) {
            // Add [...] button if there are more pages after
            htmlPag += '<span>...</span>';
        }

        if (pageNumber === lastPageNumber) {
            // Make both button disable
            htmlPag += '<span>&gt;</span><span>&gt;&gt;</span>';
        } else {
            htmlPag += `<a href="${linkSupplier(pageNumber + 1)}">&gt;</a><a href="${linkSupplier(lastPageNumber)}" title="${linkSupplier(lastPageNumber)}">&gt;&gt;</a>`;
        }

        htmlPag += '</div>';

        return htmlPag;
    };

    const shorten = (string, length, suffix = '...') => {
        if (string.length < length - suffix.length) {
            // Shorter than expected
            return string;
        }

        return string.substr(0, length - suffix.length).concat(suffix);
    };

    const paddingZero = (str, size) => {
        for (let i = 0; i < size - str.length; i++)
            str = "0" + str;

        return str;
    };

    const formatUTCUnixEpoch = (unixEpoch) => {
        const date = new Date(unixEpoch * 1000);
        const year = date.getUTCFullYear().toString();
        const month = paddingZero((date.getUTCMonth() + 1).toString(), 2);  // Note: Jan === 0 weird
        const day = paddingZero(date.getUTCDate().toString(), 2);
        const hours = paddingZero(date.getUTCHours().toString(), 2);
        const minutes = paddingZero(date.getUTCMinutes().toString(), 2);
        const seconds = paddingZero(date.getUTCSeconds().toString(), 2);

        return `UTC ${year}/${month}/${day} ${hours}:${minutes}:${seconds}`;
    };

    const humanizeSec = (sec) => {
        if (sec === 1) {
            return '1 second';
        } else if (sec < 60) {
            return `${sec} seconds`
        } else if (sec < 60 * 60) {
            const mins = Math.floor(sec / 60);

            // Difference if only suffixed by 's'
            if (mins === 1) {
                return '1 minute';
            } else {
                return `${mins} minutes`;
            }
        } else if (sec < 60 * 60 * 24) {
            const hours = Math.floor(sec / 60 / 60);

            if (hours === 1) {
                return '1 hour';
            } else {
                return `${hours} hours`;
            }
        } else {
            // When difference is over a day, count in days

            const days = Math.floor(sec / 60 /60 / 24);

            if (days === 1) {
                return '1 day';
            } else {
                return `${days} days`;
            }
        }
    };

    const calcDiffUnixEpochFromNow = (unixEpoch) => {
        return Math.floor(Date.now() / 1000) - unixEpoch;   // Date.now() returns UTC time
    };

    const humanizeUnixEpochDiffFromNow = (unixEpoch) => {
        const diff = calcDiffUnixEpochFromNow(unixEpoch);   // Difference but not absolute, negative value means future from now

        if (diff === 0) {
            return 'now';   // Just now !!!
        } else if (diff > 0) {
            return `${humanizeSec(diff)} ago`;  // Things happened earlier
        } else {
            // diff < 0
            return `${humanizeSec(diff)} later`;    // Things that will happen (!!!)
        }
    };

    const genAddressIconCanvas = (address) => {
        let option = {
            seed: address,
            scale: 5,
            size: 10
        };

        return blockies.create(option);
    };

    const _drawClock = (context, hours, minutes, seconds) => {
        let stheta = (seconds * 2 * Math.PI) / 60;
        let mtheta = ((minutes + seconds / 60) * 2 * Math.PI) / 60;
        let htheta = ((hours + minutes / 60 + seconds / (60 * 60)) * 2 * Math.PI) / 12;

        let ssin = Math.sin(stheta);
        let scos = Math.cos(stheta);
        let msin = Math.sin(mtheta);
        let mcos = Math.cos(mtheta);
        let hsin = Math.sin(htheta);
        let hcos = Math.cos(htheta);

        // Clear all with rectangle
        context.clearRect(0, 0, 200, 200);

        // Outer frame
        context.beginPath();
        context.lineWidth = 2;
        context.arc(100, 100, 98, 0, 2 * Math.PI);
        context.closePath();
        context.stroke();

        context.font = 'bold 20px sans-serif';
        context.textAlign = "center";
        context.textBaseline = "bottom";
        context.fillText('UTC', 100, 77);

        // Second hand
        context.beginPath();
        context.lineWidth = 1;
        context.moveTo(100 - 15 * ssin, 100 + 15 * scos);
        context.lineTo(100 + 80 * ssin, 100 - 80 * scos);
        context.stroke();

        // Minute hand
        context.beginPath();
        context.lineWidth = 3;
        context.moveTo(100 - 5 * msin, 100 + 5 * mcos);
        context.lineTo(100 + 90 * msin, 100 - 90 * mcos);
        context.stroke();

        // Hour hand
        context.beginPath();
        context.lineWidth = 6;
        context.moveTo(100 - 5 * hsin, 100 + 5 * hcos);
        context.lineTo(100 + 60 * hsin, 100 - 60 * hcos);
        context.stroke();
    };

    const drawClock = (context, unixEpoch) => {
        let date = new Date(unixEpoch * 1000);
        let seconds = date.getUTCSeconds();
        let minutes = date.getUTCMinutes();
        let hours = date.getUTCHours() % 12;

        _drawClock(context, hours, minutes, seconds);
    };

    /**
     * Perform an drawing of current time to the context
     * @param context
     */
    const drawClockNow = (context) => {
        let date = new Date();
        let seconds = date.getUTCSeconds();
        let minutes = date.getUTCMinutes();
        let hours = date.getUTCHours() % 12;

        _drawClock(context, hours, minutes, seconds);
    };

    // Networking

    class BlockNumberStreamService {
        constructor() {
            this.listeners = new Map();   // Listeners listening to the block number stream
            this.latestNumber = undefined;
        }

        startConnectingAndKeep() {
            this.websocket = new WebSocket('ws://localhost:8080/block-number');

            this.websocket.onclose = function () {  // Try to reconnect if connection is lost
                console.log("Connection closed, retrying");
                setInterval(this.startConnectingAndKeep, 5000);
            };

            let self = this;

            this.websocket.onmessage = function (event) {
                self.latestNumber = event.data;
                self.listeners.forEach((v, k) => v(event.data)); // Call listeners
            };
        }

        registerListener(id, listener) {
            this.listeners.set(id, listener);
            listener(this.latestNumber);
        }

        removeListener(id) {
            this.listeners.delete(id);
        }
    }

    class RequestService {
        constructor() {
            this.connected = false;
            this.connecting = false;
            this.connId = 0;
        }

        connectIfNot() {
            if (this.connected || this.connecting) {
                // Connection is already established or trying to
                return;
            }

            /* Connect to the server */
            this.connecting = true;

            this.callbacks = new Map(); // Create map for storing a nonce and callbacks pair
            this.websocket = new WebSocket('ws://localhost:8080/request');  // Connect to the request websocket server

            let self = this;

            this.websocket.onopen = function () {
                self.connected = true;
                self.connecting = false;
                console.debug("CONNECTION OPENED");
            };
            this.websocket.onclose = function () {
                self.connected = false;
                self.connecting = false;
                console.debug("CONNECTION CLOSED");
            };

            this.websocket.onmessage = function (event) {  // Set onmessage listener
                let response = JSON.parse(event.data); // Parsing from STRING to OBJECT, not otherwise
                let id = response['id'];

                let callback = self.callbacks.get(id);  // Get callback for the id

                callback(response['content']); // Call callback function

                self.callbacks.delete(id);  // Delete callback from the map
            };

            this.nonce = 0; // Initial nonce is 0
            this.connId++;  // Increment connection id
        }

        connectAndRequest(demand, content, callback) {
            this.connectIfNot();

            let wrapped = { // Wrap content
                id: this.nonce,
                demand: demand,
                content: content
            };

            let message = JSON.stringify(wrapped);

            this.callbacks.set(this.nonce, callback);       // Store the callback for response
            this.nonce++;   // Inclement nonce for the next request

            if (this.connected) {
                /* A connection is already established, sending a request immediately */
                this.websocket.send(message);   // Send a request to the server
                console.debug("send#1");
            } else {
                /* Send message to server, retry if connection is not ready */
                let self = this;
                let storedConnId = this.connId;

                let timerId = setInterval(function () {
                    if (self.connId !== storedConnId) {
                        // Connection changed, maybe reestablished
                        clearInterval(timerId); // This function is no longer be called
                        console.debug("discarded#1");

                    } else if (self.connected) {
                        self.websocket.send(message);   // Send to request websocket server
                        clearInterval(timerId); // Stop calling this function
                        console.debug("send#2");

                    } else if (!self.connecting) {
                        // Connection is not established but not trying to
                        clearInterval(timerId); // Guess connection failed
                        console.debug("discarded#2");
                    }
                }, 100);
            }
        }
    }

    const blockNumberStreamService = new BlockNumberStreamService();
    blockNumberStreamService.startConnectingAndKeep();  // Start connecting to the block number streaming service asynchronously
    const requestService = new RequestService();      // Request service will connect to the server in future when it is needed

    // Search box

    let searchStateId = 0;
    let searchTimeoutId;

    search_box.addEventListener('input', function () {
        // Registering search box input event

        // Gets the inputted string from the search box
        let search_string = search_box.value;

        if (search_string.length === 0) {
            // todo If search word is empty string, show nothing
        }

        let stored_ssid = ++searchStateId;

        if (searchTimeoutId !== undefined) {
            // Cancel former search wait
            clearTimeout(searchTimeoutId);
        }

        // Wait for the user inputting to settle
        searchTimeoutId = setTimeout(function () {
            requestService.connectAndRequest('search', search_string, function (content) {
                if (searchStateId !== stored_ssid) {
                    // Another search was issued later, discard this
                    console.debug("s_discarded");
                    return;
                }

                let suggestionHTML = "";
                for (let i = 0; i < content.length; i++) {
                    let link_label;

                    switch (content[i][0]) {
                        case 'block_number':        link_label = "Block Number"; break;
                        case 'block_hash':          link_label = "Block"; break;
                        case 'transaction_hash':    link_label = "Transaction"; break;
                        case 'normal_address':      link_label = "Address"; break;
                        case 'contract_address':    link_label = "Contract Address"; break;
                    }

                    link_label += " " + content[i][1];

                    suggestionHTML += `<li>${link_label}</li>`;
                }

                search_suggestions.innerHTML = suggestionHTML;
            });
        }, 250);
    });

    document.getElementById('search-form').addEventListener('submit', function (event) { // Event listener for search confirm
        event.preventDefault();
        alert("is it");
        return false;
    });

    // View deceleration

    let currentView;    // Current opened view

    class View {

        // Must call loadingEnd in open function
        open() {}

        close() {}

        beforeClosing() {}

        afterClosed() {}

        getTitle() {}
    }

    class ViewError extends View {

        constructor(errMsg) {
            super();
            this.errMsg = errMsg;
        }

        open() {
            div_contents.innerHTML = `<h1>Error: ${this.errMsg}</h1>`;

            loadingEnd();
        }

        getTitle() {
            return 'Error';
        }
    }

    // Opens a new view
    const openView = (newView) => {
        loadingStart(); // TODO weird placement

        let lastView = currentView;

        if (lastView !== undefined) {
            // Close the previous view
            lastView.beforeClosing();
            lastView.close();
            lastView.afterClosed();
        }

        newView.open();

        currentView = newView;
    };

    // Page transitions

    const selectView = (path) => {
        if (path === '/' || path === '') {
            // Returns home view
            return VIEW_HOME;
        }

        // Split string in array
        const splint = path.split('/');

        if (splint[0] === 'block') {
            if (splint.length === 3) {
                if (splint[1] === 'hash') {
                    if (!isBlockHash(splint[2])) {
                        return new ViewError('Invalid block hash');
                    }

                    return new ViewBlock('hash', splint[2]);
                } else if (splint[1] === 'number') {
                    let fl = parseFloat(splint[2]);

                    if (!isNaN(splint[2]) && Number.isInteger(fl)) {
                        let it = parseInt(splint[2]);

                        return new ViewBlock('number', it.toString(10));

                    } else {
                        return new ViewError('Non integer value entered');
                    }
                }
            } else if (splint.length === 5 && splint[3] === 'txs') {
                if (!isNonNegativeInt(splint[4])) {
                    return new ViewError("Page number has to be integer");
                }

                // Parse it as integer
                const pageNumber = parseInt(splint[4]);

                if (pageNumber < 1) {
                    return new ViewError("Page number has to be positive and not zero")
                }

                if (splint[1] === 'hash') {
                    if (!isBlockHash(splint[2])) {
                        return new ViewError('Invalid block hash');
                    }

                    return new ViewTransactionList('block-hash', splint[2], pageNumber);
                } else if (splint[1] === 'number') {
                    if (!isNonNegativeInt(splint[2])) {
                        return new ViewError("Non integer value as 'number'");
                    }

                    return new ViewTransactionList('block-number', splint[2], pageNumber);
                } else if (splint[1] === 'id') {
                    if (!isNonNegativeInt(splint[2])) {
                        return new ViewError("Non integer value as 'number'");
                    }
                    if (parseInt(splint[2]) > 0) {
                        return new ViewError("'id' should be positive and not 0");
                    }

                    return new ViewTransactionList('block-id', splint[2], pageNumber);
                }
            }

            return new ViewError('Block selection type unknown');
        } else if (splint[0] === 'tx' && splint.length === 3) {
            if (splint[1] === 'hash') {
                if (isTxHash(splint[2])) {
                    // TODO
                }
            }
        } else if (splint[0] === 'address') {
            if (splint.length === 3) {
                if (splint[1] === 'hash') {
                    if (!isAddressHash(splint[2])) {
                        return new ViewError('Invalid address hash');
                    }

                    return new ViewAddress('hash', splint[2]);
                }

                return new ViewError('Address selection type unknown');

            } else if (splint.length === 5) {
                if (splint[1] !== 'hash') {
                    return new ViewError('Address selection type unknown');
                }
                if (!isAddressHash(splint[2])) {
                    return new ViewError('Invalid address hash');
                }
                if (!isNonNegativeInt(splint[4])) {
                    return new ViewError('Page number should be integer');
                }

                const pageNumber = parseInt(splint[4]);

                if (pageNumber < 0) {
                    return new ViewError('Page number should be positive and not 0');
                }

                if (splint[3] === 'txs') {
                    return new ViewTransactionList('address-hash', splint[2], pageNumber);
                } else if (splint[3] === 'mined') {
                    // TODO
                }
            }

            // Invalid URL
        } else if (splint[0] === 'blocks' && splint.length === 2) {
            if (!isNonNegativeInt(splint[1])) {
                return new Error('Page number should be interger');
            }

            const pageNumber = parseInt(splint[1]);

            if (pageNumber < 0) {
                return new Error('Page number should be positive and not 0');
            }

            return new ViewBlockList(pageNumber);
        } else if (splint[0] === 'transactions' && splint.length === 1) {
        }

        return new ViewError('Invalid URL');
    };

    const transitView = (path, makeHistory) => {
        let selectedView = selectView(path.substr(1));

        openView(selectedView);

        const viewTitle = selectedView.getTitle();

        if (makeHistory) {
            history.pushState(path, viewTitle, path); // Add new history for browser. This will change url in the bar
        } else {
            history.replaceState(path, viewTitle, path);    // Replace current state of history of browser
        }

        document.title = `${viewTitle} | ${SITE_TITLE}`; // Change the page title to view title
    };

    const addAllAnchorsEvent = (node) => {
        let anchors = node.querySelectorAll('a');

        if (anchors === null) {
            return; // There was no anchors
        }

        for (let link of anchors) {
            link.addEventListener('click', function (event) {
                event.preventDefault(); // This would prevent browser to actually move to target url

                const href = event.target.getAttribute('href');
                transitView(href, true);
            });
        }
    };

    // Listening to popstate event makes transition to happen when browser's history button is pressed
    window.addEventListener('popstate', event => {
        transitView(event.state, false);
    });

    // Loading screens

    const loadingStart = () => {
        document.getElementById('loading').style.display = 'block';
    };

    const loadingEnd = () => {
        document.getElementById('loading').style.display = 'none';
    };

    /* Common Declaration End */

    /* Home View Declaration Start */

    class ViewHome extends View {

        open() {
            div_contents.innerHTML =
                `<div class="pure-u-1">
üêæWIPüêæ
    <div id="latest_updates"></div>
</div>`;
            // TODO Registering events

            loadingEnd();
        }

        getTitle() {
            return 'Home';
        }
    }

    const VIEW_HOME = new ViewHome();

    /* Home View Declaration End */

    /* Block List View Declaration Start */

    const BLOCK_LIST_PAG_BUTTON_LIMIT = 9;

    class ViewBlockList extends View {

        constructor(pageNumber) {
            super();
            this.pageNumber = pageNumber;
        }

        getTitle() {
            return `Page ${this.pageNumber} Block List`;
        }

        open() {
            // Send request to the server

            let self = this;

            // TODO change this using `await`
            requestService.connectAndRequest("block-list", ['page', this.pageNumber], function (response) {
                self._requestCallback(response);
                loadingEnd();
            });
        }

        _requestCallback(response) {
            // Generate table content
            const tableContent = this._genTableContent(response[0]);
            const lastPageNumber = response[1];

            // Link supplier for generating pagination
            const linkSupplier = (pageNumber) => {
                return `/blocks/${pageNumber}`;
            };

            // Replace content
            div_contents.innerHTML = `${generatePagination('blocklist-pagination-top', BLOCK_LIST_PAG_BUTTON_LIMIT, this.pageNumber, lastPageNumber, linkSupplier)}
                <table id="blocklist-table" class="pure-table pure-table-striped">
                    <thead>
                    <tr><th>#</th><th>Hash</th><th>Miner</th><th>Tx#</th><th>Uncle#</th><th>Forked?</th></tr>
                    </thead>
                    <tbody>
                    ${tableContent}
                    </tbody>
                </table>
            ${generatePagination('blocklist-pagination-bottom', BLOCK_LIST_PAG_BUTTON_LIMIT, this.pageNumber, lastPageNumber, linkSupplier)}`;

            // Add all generated link event listener
            addAllAnchorsEvent(div_contents);
        }

        changePageTo(pageNumber) {
            loadingStart();

            let tableDiv = document.querySelector('#blocklist-table tbody');

            let self = this;

            requestService.connectAndRequest('block-list', ['page', pageNumber], function (response) {
                tableDiv.innerHTML = self._genTableContent(response[0]);

                loadingEnd();
            });
        }

        _genTableContent(blocks) {
            let tableContent = '';

            for (let i in blocks) {
                const blockelm = blocks[i];
                const id = blockelm[0];
                const number = blockelm[1];
                const hash = blockelm[2];
                const miner = blockelm[3];
                const txCount = blockelm[4];
                const uncleCount = blockelm[5];
                const forked = blockelm[6];

                if (forked) {
                    tableContent +=
                        `<tr>
                    <td>${number}</td>
                    <td>${shorten(hash, 12)}</td>
                    <td><a href="/address/hash/${miner}">${shorten(miner, 25)}</a></td>
                    <td><a href="/block/id/${id}/txs/1">${txCount}</a></td>
                    <td><a href="/block/id/${id}/mined/1">${uncleCount}</a></td>
                    <td><i class="fa fa-code-fork" aria-hidden="true"></i></td>
                    </tr>`;
                } else {
                    tableContent +=
                        `<tr>
                    <td><a href="/block/number/${number}">${number}</a></td>
                    <td><a href="/block/hash/${hash}">${shorten(hash, 12)}</a></td>
                    <td><a href="/address/hash/${miner}">${shorten(miner, 25)}</a></td>
                    <td><a href="/block/number/${number}/txs/1">${txCount}</a></td>
                    <td><a href="/block/number/${number}/mined/1">${uncleCount}</a></td>
                    <td></td>
                    </tr>`;
                }

                // TODO Open with id if forked block, with number if not

            }

            return tableContent;
        }
    }

    /* Block List View Declaration End */

    /* Block View Declaration Start */

    const MAX_INIT_BLOCK_LIST_ELEMENTS_PER_SIDE = 100;  // This can't be small enough to fit the biggest screen in the world
    const BLOCK_LIST_ELEMENTS_LOAD_N = 20;  // Maximum of this number of block list elements are added each time when scroll change is performed
    const BLOCK_LIST_BNSS_KEY = 'block_list';

    class ViewBlock extends View {

        constructor(key, value) {
            super();
            this.targetKey = key;
            this.targetValue = value;
            this.blocklistInner = null; // Div element which is is block-list-inner
            this.blocklist = null;      // Div element which id is block-list

            this.latestBlockNumber = null; // Latest block number known by the client
            this.blockListInitialized = false;
            this.scrollCheckIntervalId = null;  // setInterval id of scrollCheck calling
            this.scrollAction = false; // Not to do scroll change if events are issued while performing it
            this.elementHeight = -1; // Height of one block list element
            this.nextTopBlockNum = null;    // Next block number will be added to the block list on BEGINNING
            this.nextBottomBlockNum = null; // Next block number will be added to the block list on END including a working block
        }

        getTitle() {
            if (this.targetKey === 'number') {
                return `Block #${this.targetValue}`;
            } else if (this.targetKey === 'hash') {
                return `Block ${this.targetValue}`;
            }
        }

        open() {
            const content = [this.targetKey, this.targetValue];

            const self = this;

            requestService.connectAndRequest('block', content, function(response) {
                self.blockRequestCallback(response);
                loadingEnd();
            });
        }

        beforeClosing() {
            clearInterval(this.scrollCheckIntervalId);  // Remove scroll check in a interval
            blockNumberStreamService.removeListener(BLOCK_LIST_BNSS_KEY);   // Remove block number listener
        }

        blockRequestCallback(response) {
            if (response === false) {
                div_contents.innerHTML = '<h1>Block did not found</h1>';
                return;
            }

            const internalId = response[0];
            const number = response[1];
            const hash = response[2];
            const parentHash = response[3];
            const timestamp = response[4];
            const miner = response[5];
            const difficulty = response[6];
            const gasLimit = response[7];
            const gasUsed = response[8];
            const extraData = response[9];
            const nonce = response[10];
            const size = response[11];
            const forked = response[12];
            const uncles = response[13];


            let uncles_html = '';
            let transactions_html = '';

            for (const uncle of uncles) {
                uncles_html += `#${uncle[1]}<br>`;
            }

            let diffBigNumber = new BigNumber(difficulty);
            let humanReadableDiff;
            let prefixIndex = 0;

            while ((diffBigNumber = diffBigNumber.div(1000)).comparedTo(1) >= 0) {
                humanReadableDiff = diffBigNumber;
                prefixIndex++;
            }

            const difficultyFormatted = humanReadableDiff.round(2).toString() + DIFF_PREFIXES[prefixIndex];
            const timestampFormatted = formatUTCUnixEpoch(timestamp);

            div_contents.innerHTML =
                `<div class="pure-g">
            <div id="blockview-left" class="pure-u-1-4">
                <div id="blockview-list">
                    <div id="blockview-list-inner">

                    </div>
                </div>
            </div>
            <div class="pure-u-3-4">
                <div id="blockview-right">
                    <h1>Block #${number}</h1>
                    <div >
                        <div class="block-time">
                            <canvas id="canvas-block-time-clock" class="block-time-clock"
                                title="${timestampFormatted}"
                                height="200px" width="200px"></canvas>
                        </div>
                        <div class="block-about">
                            <span class="mini-caption">Hash</span><span class="captioned-text">${hash}</span>
                            <span class="mini-caption">Miner</span><span class="captioned-text">${miner}</span>
                            <span class="mini-caption">Difficulty</span><span class="captioned-text" title="${difficulty}">${difficultyFormatted}</span>
                            <span class="mini-caption">Gas</span>
                            <span class="captioned-text">
                            <span title="The amount of gas used in this block">${gasUsed}</span> / <span title="The upper limit of gas could be used in this block">${gasLimit}</span>
                            </span>
                            <span class="mini-caption">Extra Data</span><span class="captioned-text">${extraData}</span>
                            <span class="mini-caption">Nonce</span><span class="captioned-text">${nonce}</span>
                            <span class="mini-caption">Size</span><span class="captioned-text">${size} bytes</span>
                            <span class="mini-caption">Internal Id</span><span class="captioned-text">${internalId}</span>
                        </div>
                    </div>
                    <h2><a href="/block/${this.targetKey}/${this.targetValue}/txs/1">Transaction(s)</a></h2>
                    <div>
                        <h2>${uncles.length} Uncle(s)</h2>

                        ${uncles_html}
                    </div>
                </div>
            </div>
        </div>`;

            const cc = document.getElementById('canvas-block-time-clock').getContext('2d');
            drawClock(cc, timestamp);

            addAllAnchorsEvent(document.getElementById('blockview-right'));

            this.blocklistInner = document.getElementById('blockview-list-inner');
            this.blocklist = document.getElementById('blockview-list');

            const self = this;

            this.blocklist.addEventListener('scroll', () => {
                self.scrollEvent(); // Functions in class doesn't have real 'value' have to call them from a function
            });  // Add event listener for block list scroll event

            this.scrollCheckIntervalId = setInterval(() => {
                console.log("called");
                self.scrollEvent();
            }, 1000);   // This is for up scroll glitch not for ie fail-safe

            blockNumberStreamService.registerListener(BLOCK_LIST_BNSS_KEY, (blockNumber) => {    // Register listener for real-time block list update
                let beforeLatestBlockNumber = self.latestBlockNumber;
                self.latestBlockNumber = new BigNumber(blockNumber);

                if (beforeLatestBlockNumber === null) {   // If this was the first message
                    /* Initialize block list */

                    self.fillBlockList(new BigNumber(blockNumber));

                    self.blockListInitialized = true;    // Block list successfully initialized, now scroll event will be performed
                } else {
                    if (self.latestBlockNumber.comparedTo(beforeLatestBlockNumber) < 0) {
                        /* Block chain reorganization happened (forking) */

                        self.nextBottomBlockNum = self.latestBlockNumber.add(1);
                        let i = self.nextBottomBlockNum;

                        /* Removing list elements who got deleted from the blockchain */
                        while (i.comparedTo(beforeLatestBlockNumber) <= 0) {
                            let rmv = document.getElementById('blockview-list-element-n' + i);
                            rmv.parentNode.removeChild(rmv);
                        }
                    } else {

                        if (self.nextBottomBlockNum.comparedTo(beforeLatestBlockNumber.add(1)) === 0) {  // Latest block are shown
//                let scrollBottom = blocklist.scrollTop === (blocklistInner.clientHeight - blocklist.clientHeight);

                            self.addToBlockList('beforeEnd', self.nextBottomBlockNum);
                            self.nextBottomBlockNum = self.nextBottomBlockNum.add(1);

//                if (scrollBottom) { // If scroll was max, set max again
//                    blocklist.scrollTop = blocklistInner.clientHeight - blocklist.clientHeight;
//                }
                        }
                    }
                }
            });
        }

        scrollEvent() {  // Add scroll event listener
            if (this.blockListInitialized && !this.scrollAction) {
//            scrollAction = true;

                if (this.blocklist.scrollTop <= this.elementHeight) {
                    /* Add more block elements on top of the list */
                    let i;

                    for (i = 0; i < BLOCK_LIST_ELEMENTS_LOAD_N; i++) {
                        if (this.nextTopBlockNum.comparedTo(0) < 0) {  // Already showing the oldest block (#0)
                            break;  // Don't add elements anymore
                        }
                        this.addToBlockList('afterBegin', this.nextTopBlockNum);   // Add an element on top of the list
                        this.nextTopBlockNum = this.nextTopBlockNum.sub(1);
                    }

                    if (i !== 0) {  // If elements are added
                        this.blocklist.scrollTop = this.elementHeight * (i + 1);  // Set scroll position to where it was, for interval execution
                    }
                } else if (this.blocklist.scrollTop >= this.blocklistInner.clientHeight - this.blocklist.clientHeight - this.elementHeight) {
                    /* Add more block elements on bottom of the list */
                    for (let i = 0; i < BLOCK_LIST_ELEMENTS_LOAD_N; i++) {
                        if (this.nextBottomBlockNum.comparedTo(this.latestBlockNumber.add(1)) > 0) {  // Already showing the latest block + 1
                            break;
                        }

                        this.addToBlockList('beforeEnd', this.nextBottomBlockNum);    // Add an element on bottom of the list
                        this.nextBottomBlockNum = this.nextBottomBlockNum.add(1);
                    }
                }

                this.scrollAction = false;
            }
        }

        fillBlockList(blockNumber) {
            this.blocklistInner.innerHTML = '';  // Clear all elements

            /* Fill block list with initial elements around the blockNumber */

            this.addToBlockList('beforeEnd', blockNumber);  // Add a center block

            this.elementHeight = this.blocklistInner.clientHeight; // Get how much y-space is needed for just one element

            this.nextTopBlockNum = blockNumber.sub(1);      // Next block number listed BEFORE the center block
            this.nextBottomBlockNum = blockNumber.add(1);   // Next block number listed AFTER the center block

            let topBlocks = Math.ceil(this.blocklist.clientHeight / this.elementHeight) + 1;  // Default value of the amount of elements listed before the center block.
            // Total height should be one element's height higher from the same as the list div height, if this number of elements are stacked

            if (topBlocks > MAX_INIT_BLOCK_LIST_ELEMENTS_PER_SIDE) {    // This stops infinite loop to happen if something went wrong
                topBlocks = MAX_INIT_BLOCK_LIST_ELEMENTS_PER_SIDE;
            }

            let bottomBlocks = topBlocks;   // Both default amount of bottom and top blocks are the same

            if (blockNumber.sub(topBlocks).comparedTo(0) < 0) {  // Check if this exceeds the lower limit of zero (minimum block number)
                topBlocks = blockNumber;    // Think blockNumber as the amount of blocks remaining on top of the center block.
                // This would list all elements from zero to before the center block
            }

            if (blockNumber.add(bottomBlocks).comparedTo(this.latestBlockNumber.add(1)) > 0) {  // Check if this exceeds the upper limit of latest block number + 1
                bottomBlocks = (this.latestBlockNumber.add(1)).sub(blockNumber).toNumber();
            }

            /* Most fun part! Add elements to the HTML */

            for (let i = 0; i < topBlocks; i++) {
                this.addToBlockList('afterBegin', this.nextTopBlockNum);    // Add element before the center block, watch out for decrement
                this.nextTopBlockNum = this.nextTopBlockNum.sub(1);
            }

            for (let i = 0; i < bottomBlocks; i++) {   // Add predecessors of the block
                this.addToBlockList('beforeEnd', this.nextBottomBlockNum);
                this.nextBottomBlockNum = this.nextBottomBlockNum.add(1);
            }

            /* Try to set scroll bar where the center block become center of the list */

            let yscroll = Math.round(this.elementHeight * (topBlocks + 0.5) - this.blocklist.clientHeight / 2);
            let yscrollMax = this.blocklistInner.clientHeight - this.blocklist.clientHeight;

            yscroll = Math.max(0, Math.min(yscroll, yscrollMax));   // Cannot scroll to negative or outside from an box

            this.blocklist.scrollTop = yscroll;  // Set scroll bar
        }

        addToBlockList(position, blockNumber) {
            this.blocklistInner.insertAdjacentHTML(position, `<span id="blockview-list-element-n${blockNumber}" class="blockview-list-element"><a href="/block/number/${blockNumber}">${blockNumber}</a></span>`);
            addAllAnchorsEvent(document.getElementById(`blockview-list-element-n${blockNumber}`));
        }
    }

    /* Block View Declaration End */

    /* Address View Declaration Start */

    const ADDRESS_TYPE = {
        NORMAL: 'NORMAL',
        CONTRACT: 'CONTRACT'
    };

    class ViewAddress extends View {

        constructor(key, value) {
            super();
            this.targetKey = key;
            this.targetValue = value;
        }

        getTitle() {
            return `Address ${this.targetValue}`;
        }

        open() {
            requestService.connectAndRequest('address', [this.targetKey, this.targetValue], (content) => {
                if (content === false) {
                    // Address was not recorded on the server
                    div_contents.innerHTML = '<h1>Address did not found</h1>';
                    loadingEnd();
                    return;
                }

                // Human readability and something
                const internalId = content[0];
                const addr_hash = content[1];
                const addr_type = content[2];
                const alias = content[3];
                const description = content[4];
                const txs_count = content[5];
                const mined_count = content[6];
                const first_appear_block = content[7];
                const first_appear_ts = content[8];
                const last_appear_block = content[9];
                const last_appear_ts = content[10];

                // Mouse over hint for 'address type'
                let addr_type_title;

                if (addr_type === ADDRESS_TYPE.NORMAL) {
                    addr_type_title = 'Normal addresses are the wallets which have a public and private key pair';
                } else if (addr_type === ADDRESS_TYPE.CONTRACT) {
                    addr_type_title = 'Contract addresses are individual addresses generated for each contract when it is created';
                } else throw new Error('Unknown address type');

                // If alias was not registered (null) then remove section
                let alias_HTML;

                if (alias === null) {
                    alias_HTML = '';
                } else {
                    alias_HTML = `<h2 title="Registered alias of this address">${alias}<i class="fa fa-check-circle reviewed-admin-icon" aria-hidden="true" title="Reviewed by admins"></i></h2>`;
                }

                // Same here
                let description_HTML;

                if (description === null) {
                    description_HTML = '';
                } else {
                    description_HTML = `<p title="Registered description for this address">${description}</p>`;
                }

                // Write it to content div
                div_contents.innerHTML = `<div id="address-wrapper">
            <canvas id="address-icon" title="This address's portrait icon (nealy unique)"></canvas>
            <div id="address-info">
                <h1><span class="box-highlighted bh-green" title="${addr_type_title}">${addr_type}</span> Address <span id="address-hash">${addr_hash}</span></h1>
                ${alias_HTML}
                ${description_HTML}
                <p id="address-tags">Tags: <span class="address-tag">?</span></p>
                <h2><a href="/address/${this.targetKey}/${this.targetValue}/txs/1">${txs_count} transactions involved</a></h2>
                <h2><a href="/address/${this.targetKey}/${this.targetValue}/mined/1">${mined_count} blocks/uncles mined</a></h2>
                <h2>Last activity at <a href="/block/number/${last_appear_block}" title="Block #${last_appear_block}"> ${formatUTCUnixEpoch(last_appear_ts)}</a> (${humanizeUnixEpochDiffFromNow(last_appear_ts)})</h2>
                <h2>First appearance at <a href="/block/number/${first_appear_block}" title="Block #${first_appear_block}"> ${formatUTCUnixEpoch(first_appear_ts)}</a> (${humanizeUnixEpochDiffFromNow(first_appear_ts)})</h2>
            </div>
        </div>`;

                // Render address icon
                const option = {
                    seed:addr_hash,
                    size: 8,
                    scale: 16
                };
                blockies.render(option, document.getElementById('address-icon'));

                // Add anchor event
                addAllAnchorsEvent(div_contents);

                loadingEnd();
            });


        }
    }

    /* Address View Declaration End */

    /* Transaction List View Declaration Start */

    const TX_LIST_PAGINATION_BUTTON_LIMIT = 9;

    const TRANSACTION_TYPE = {
        SEND: 'SEND',
        CONTRACT_CREATION: 'CONTRACT_CREATION',
        CONTRACT_CALL: 'CONTRACT_CALL'
    };

    class ViewTransactionList extends View {

        constructor(key, value, pageNumber) {
            super();
            this.targetKey = key;
            this.targetValue = value;
            this.pageNumber = pageNumber;
        }

        getTitle() {
            return `Page ${this.pageNumber} Txs of ${this.targetKey.substr(0, this.targetKey.indexOf('-'))} ${this.targetValue}`;
        }

        open() {
            const baseURL = `/${this.targetKey.replace('-', '/')}/${this.targetValue}`;

            const linkSupplier = (pageNumber) => {
                return `${baseURL}/txs/${pageNumber}`;
            };

            requestService.connectAndRequest('transaction-list', [this.targetKey, this.targetValue, this.pageNumber], (content) => {
                const pageReq = content[0];
                const lastPageNumber = content[1];
                const discoveredRows = content[2];
                const serverRowLimit = content[3];

                if (this.targetKey === 'address-hash') {
                    let tableBodyHTML = '';

                    for (const elem of pageReq) {
                        const txType = elem[0];
                        const txHash = elem[1];
                        const blockNumber = elem[2];
                        const timestamp = elem[3];
                        const fromAddr = elem[4];
                        const targetAddr = elem[5];
                        const value = new BigNumber(elem[6]);

                        const txTypeHumanized = ViewTransactionList.humanizeTxType(txType);
                        const txTypeIcon = ViewTransactionList.getIconFor(txType);
                        const cssTypeCode = txType.toLowerCase().replace('_', '-');
                        const capLoweredValue = this.targetValue.toLowerCase();
                        const fromAddrHTML = (fromAddr === capLoweredValue) ? 'This address' : `<a href="/address/hash/${fromAddr}">${shorten(fromAddr, 20)}</a>`;
                        const targetAddrHTML = (targetAddr === capLoweredValue) ? 'This address' : `<a href="/address/hash/${targetAddr}">${shorten(targetAddr, 20)}</a>`;
                        const valueWithDecimal = value.div(ONE_NUKO);

                        tableBodyHTML += `<tr><td><a href="/block/number/${blockNumber}">${blockNumber}</a> (${humanizeUnixEpochDiffFromNow(timestamp)})</td>
<td><a href="/transaction/hash/${txHash}"><span class="tx-list-hexprefix tx-list-highlight-${cssTypeCode}">0x</span>${shorten(txHash.substr(2), 15)}</a></td>
<td>${txTypeHumanized}</td><td><span title="${valueWithDecimal} NUKO">${valueWithDecimal.round(2)} NUKO</span></td><td>${fromAddrHTML}</td>
<td><span class="tx-list-coloring-${cssTypeCode}">${txTypeIcon}</span>${targetAddrHTML}</td></tr>`;
                    }

                    let rowCountHTML;
                    let warning;
                    if (discoveredRows > serverRowLimit) {
                        rowCountHTML = `${serverRowLimit}+`;
                        warning = "<p>‚ö†This address's transactions are too many and results are limited by server</p>";
                    } else {
                        rowCountHTML = discoveredRows.toString();
                        warning = '';
                    }

                    div_contents.innerHTML = `<h1>Address <a href="${baseURL}">${this.getSourceParentName()}</a>'s transactions (${rowCountHTML})</h1>
        ${warning}
        ${generatePagination('tx-list-pagination-top', TX_LIST_PAGINATION_BUTTON_LIMIT, this.pageNumber, lastPageNumber, linkSupplier)}
        <table id="tx-list-table" class="pure-table pure-table-striped">
            <thead><tr><th>Time</th><th>Hash</th><th>Type</th><th>Value</th><th>From</th><th>Target</th></tr></thead>
            <tbody>
                ${tableBodyHTML}
            </tbody>
        </table>
    ${generatePagination('tx-list-pagination-top', TX_LIST_PAGINATION_BUTTON_LIMIT, this.pageNumber, lastPageNumber, linkSupplier)}`;

                } else if (this.targetKey === 'block-hash' || this.targetKey === 'block-number' || this.targetKey === 'block-id') {

                    let tableBodyHTML = '';

                    for (const elem of pageReq) {
                        const txType = elem[0];
                        const txHash = elem[1];
                        const fromAddr = elem[2];
                        const targetAddr = elem[3];
                        const value = new BigNumber(elem[4]);

                        const txTypeHumanized = ViewTransactionList.humanizeTxType(txType);
                        const txTypeIcon = ViewTransactionList.getIconFor(txType);
                        const cssTypeCode = txType.toLowerCase().replace('_', '-');
                        const fromAddrHTML = `<a href="/address/hash/${fromAddr}">${shorten(fromAddr, 20)}</a>`;
                        const targetAddrHTML = `<a href="/address/hash/${targetAddr}">${shorten(targetAddr, 20)}</a>`;
                        const valueWithDecimal = value.div(ONE_NUKO);

                        tableBodyHTML += `<tr><td><a href="/transaction/hash/${txHash}"><span class="tx-list-hexprefix tx-list-highlight-${cssTypeCode}">0x</span>${shorten(txHash.substr(2), 15)}</a></td>
<td>${txTypeHumanized}</td><td><span title="${valueWithDecimal} NUKO">${valueWithDecimal.round(2)} NUKO</span></td><td>${fromAddrHTML}</td>
<td><span class="tx-list-coloring-${cssTypeCode}">${txTypeIcon}</span>${targetAddrHTML}</td></tr>`;
                    }

                    let rowCountHTML;
                    if (discoveredRows > serverRowLimit) {
                        rowCountHTML = `${serverRowLimit}+`;
                    } else {
                        rowCountHTML = discoveredRows.toString();
                    }

                    div_contents.innerHTML = `<h1>Transactions in Block <a href="${baseURL}">${this.getSourceParentName()}</a> (${rowCountHTML})</h1>
        ${generatePagination('tx-list-pagination-top', TX_LIST_PAGINATION_BUTTON_LIMIT, this.pageNumber, lastPageNumber, linkSupplier)}
        <table id="tx-list-table" class="pure-table pure-table-striped">
            <thead><tr><th>Hash</th><th>Type</th><th>Value</th><th>From</th><th>Target</th></tr></thead>
            <tbody>
                ${tableBodyHTML}
            </tbody>
        </table>
    ${generatePagination('tx-list-pagination-top', TX_LIST_PAGINATION_BUTTON_LIMIT, this.pageNumber, lastPageNumber, linkSupplier)}`;

                } else {
                    throw new Error('Unknown key type');
                }

                addAllAnchorsEvent(div_contents);

                loadingEnd();
            });
        }

        getSourceParentName() {
            if (this.targetKey.split('-')[1] === 'number') {
                return `#${this.targetValue}`;
            }

            return this.targetValue;
        }

        static humanizeTxType(txType) {
            if (txType === TRANSACTION_TYPE.SEND) {
                return 'Transfer';
            } else if (txType === TRANSACTION_TYPE.CONTRACT_CREATION) {
                return 'Create';
            } else if (txType === TRANSACTION_TYPE.CONTRACT_CALL) {
                return 'Call';
            }

            return null;
        }

        static getIconFor(txType) {
            if (txType === TRANSACTION_TYPE.SEND) {
                return '‚û°&#xFE0E;';
            } else if (txType === TRANSACTION_TYPE.CONTRACT_CREATION) {
                return 'üí•&#xFE0E;';
            } else if (txType === TRANSACTION_TYPE.CONTRACT_CALL) {
                return 'üì£&#xFE0E;';
            }

            return null;
        }
    }

    /* Transaction List View Declaration End */

    /* Initialization Start */

    // Add inner link event for menu and title
    addAllAnchorsEvent(document.getElementsByTagName('header')[0]);

    transitView(location.pathname, false);
</script>

<footer>
<div class="pure-g">
<div class="pure-u-1-1">
    2017-2018 Made with ‚ù§ by Cupmouse <a href="https://twitter.com/Cupnmouse" target="_blank"><i style="color: #1da1f2" class="fa fa-twitter" aria-hidden="true"></i></a><br>
    <!-- Just kidding, who the hell loves code. Is it kind of a weird fetish? -->
</div>
</div>
</footer>
</body>
</html>