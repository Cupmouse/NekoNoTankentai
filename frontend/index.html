<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Nekonium Block Explorer</title>
    <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css"
          integrity="sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w" crossorigin="anonymous">
    <link rel="stylesheet" href="./css/font-awesome.min.css">
    <link rel="stylesheet" href="./css/main.css">
    <script type="application/javascript" src="js/Chart.min.js"></script>
    <script type="application/javascript" src="js/bignumber.min.js"></script>
</head>
<body>
<header>
    <div class="pure-g">
        <div class="pure-u-3-4">
            <a id="title" href="#" onclick="loadViewHome()">üö©„Å≠„Åì„ÅÆÊé¢Ê§úÈöä</a>

            <div id="menu" class="pure-menu pure-menu-horizontal">
            <nav>
                <ul class="pure-menu-list">
                    <li class="pure-menu-item">
                        <a href="#" onclick="loadViewBlock('170317')" class="pure-menu-link"><i class="fa fa-th-large" aria-hidden="true"></i> Blocks</a>
                    </li>
                    <li class="pure-menu-item">
                        <a href="#" onclick="loadViewTransactionList()" class="pure-menu-link"><i class="fa fa-exchange" aria-hidden="true"></i> Transactions</a>
                    </li>
                    <li class="pure-menu-item pure-menu-disabled">
                        <i class="fa fa-bar-chart" aria-hidden="true"></i> Statistics
                    </li>
                </ul>
            </nav>
            </div>
        </div>
        <div class="pure-u-1-4">
            <div id="mini-statistics" class="pure-g text-selectable">
                <div class="pure-u-1-3">
                    # 1000000
                </div>
                <div class="pure-u-1-3">
                    Diff 150T
                </div>
                <div class="pure-u-1-3">
                    ¬• 1000
                </div>
            </div>
        </div>
        <div class="pure-u-1">
            <form id="search-form" class="pure-form">
                <input type="text" id="search-box" class="pure-input-1" placeholder="Search">
            </form>
            <div id="search-suggestions">
                <ul id="search-suggestion-list">
                </ul>
            </div>
        </div>
    </div>
</header>
<div id="contents-wrapper">
    <!-- Loading screen appears only on view loading -->
    <div id="loading">
        LOADING...
    </div>
    <!-- Inserts an contents in this div tag using Ajax -->
    <div id="contents">


    </div>
</div>

<script type="application/javascript">
    loadingStart(); // Show loading screen (It should already be shown before this)

    /* Common Declaration Start */
    const ONE_NUKO = new BigNumber(10).pow(18);

    let div_contents = document.getElementById('contents');
    let search_box = document.getElementById('search-box');
    let search_suggestions = document.getElementById('search-suggestion-list');

    let viewClosingHandler; // Called when closing current view, for listener unregistration

    class BlockNumberStreamService {
        constructor() {
            this.listener = new Map();   // Listeners listening to the block number stream
        }

        startConnectingAndKeep() {
            this.websocket = new WebSocket('ws://localhost:8080/block-number');

            this.websocket.onclose = function () {  // Try to reconnect if connection is lost
                console.log("Connection closed, retrying");
                setInterval(this.startConnectingAndKeep, 5000);
            };

            let self = this;

            this.websocket.onmessage = function (event) {
                self.listener.forEach((v, k) => k(event.data)); // Call listeners
            };
        }

        registerListener(id, listener) {
            this.listener.set(id, listener);
        }

        removeListener(id) {
            this.listener.delete(id);
        }
    }

    class RequestService {
        constructor() {
            this.connected = false;
            this.connecting = false;
            this.connId = 0;
        }

        connectIfNot() {
            if (this.connected || this.connecting) {
                // Connection is already established or trying to
                return;
            }

            /* Connect to the server */
            this.connecting = true;

            this.callbacks = new Map(); // Create map for storing a nonce and callbacks pair
            this.websocket = new WebSocket('ws://localhost:8080/request');  // Connect to the request websocket server

            let self = this;

            this.websocket.onopen = function () {
                self.connected = true;
                self.connecting = false;
                console.debug("CONNECTION OPENED");
            };
            this.websocket.onclose = function () {
                self.connected = false;
                self.connecting = false;
                console.debug("CONNECTION CLOSED");
            };

            this.websocket.onmessage = function (event) {  // Set onmessage listener
                let response = JSON.parse(event.data); // Parsing from STRING to OBJECT, not otherwise
                let id = response['id'];

                let callback = self.callbacks.get(id);  // Get callback for the id

                callback(response['content']); // Call callback function

                self.callbacks.delete(id);  // Delete callback from the map
            };

            this.nonce = 0; // Initial nonce is 0
            this.connId++;  // Increment connection id
        }

        connectAndRequest(demand, content, callback) {
            this.connectIfNot();

            let wrapped = { // Wrap content
                id: this.nonce,
                demand: demand,
                content: content
            };

            let message = JSON.stringify(wrapped);

            this.callbacks.set(this.nonce, callback);       // Store the callback for response
            this.nonce++;   // Inclement nonce for the next request

            if (this.connected) {
                /* A connection is already established, sending a request immediately */
                this.websocket.send(message);   // Send a request to the server
                console.debug("send#1");
            } else {
                /* Send message to server, retry if connection is not ready */
                let self = this;
                let storedConnId = this.connId;

                let timerId = setInterval(function () {
                    if (self.connId !== storedConnId) {
                        // Connection changed, maybe reestablished
                        clearInterval(timerId); // This function is no longer be called
                        console.debug("discarded#1");

                    } else if (self.connected) {
                        self.websocket.send(message);   // Send to request websocket server
                        clearInterval(timerId); // Stop calling this function
                        console.debug("send#2");

                    } else if (!self.connecting) {
                        // Connection is not established but not trying to
                        clearInterval(timerId); // Guess connection failed
                        console.debug("discarded#2");
                    }
                }, 100);
            }
        }
    }

    let blockNumberStreamService = new BlockNumberStreamService();
    blockNumberStreamService.startConnectingAndKeep();  // Start connecting to the block number streaming service asynchronously
    let requestService = new RequestService();      // Request service will connect to the server in future when it is needed

    let searchStateId = 0;
    let searchTimeoutId;

    search_box.addEventListener('input', function () {  // Registering search box input event
        // Gets the inputted string from the search box
        let search_string = search_box.value;

        if (search_string.length === 0) {
            // todo If search word is empty string, show nothing
        }

        let stored_ssid = ++searchStateId;

        if (searchTimeoutId !== undefined) {
            // Cancel former search wait
            clearTimeout(searchTimeoutId);
        }

        // Wait for the user inputting to settle
        searchTimeoutId = setTimeout(function () {
            requestService.connectAndRequest('search', search_string, function (content) {
                if (searchStateId !== stored_ssid) {
                    // Another search was issued later, discard this
                    console.debug("s_discarded");
                    return;
                }

                let suggestionHTML = "";
                for (let i = 0; i < content.length; i++) {
                    let link_label;

                    switch (content[i][0]) {
                        case 'block_number':        link_label = "Block Number"; break;
                        case 'block_hash':          link_label =  "Block"; break;
                        case 'transaction_hash':    link_label =  "Transaction"; break;
                        case 'normal_address':      link_label =  "Address"; break;
                        case 'contract_address':    link_label =  "Contract Address"; break;
                    }

                    link_label += " " + content[i][1];

                    suggestionHTML += `<li>${link_label}</li>`;
                }

                search_suggestions.innerHTML = suggestionHTML;
            });
        }, 250);
    });

    document.getElementById('search-form').addEventListener('submit', function () { // Event listener for search confirm
        alert("is it");
        return false;
    });

    function loadingStart() {
        document.getElementById('loading').style.display = 'block';
    }
    function loadingEnd() {
        document.getElementById('loading').style.display = 'none';
    }

    function callViewClosingHandlerIfExist() {
        if (viewClosingHandler !== undefined) { // Call view closing handler if exists
            viewClosingHandler();
            viewClosingHandler = undefined;
        }
    }

    function drawClock(context, unixEpoch) {
        let date = new Date(unixEpoch * 1000);
        let seconds = date.getUTCSeconds();
        let minutes = date.getUTCMinutes();
        let hours = date.getUTCHours() % 12;

        _drawClock(context, hours, minutes, seconds);
    }

    /**
     * Perform an drawing of current time to the context
     * @param context
     */
    function drawClockNow(context) {
        let date = new Date();
        let seconds = date.getUTCSeconds();
        let minutes = date.getUTCMinutes();
        let hours = date.getUTCHours() % 12;

        _drawClock(context, hours, minutes, seconds);
    }

    function _drawClock(context, hours, minutes, seconds) {
        let stheta = (seconds * 2 * Math.PI) / 60;
        let mtheta = ((minutes + seconds / 60) * 2 * Math.PI) / 60;
        let htheta = ((hours + minutes / 60 + seconds / (60 * 60)) * 2 * Math.PI) / 12;

        let ssin = Math.sin(stheta);
        let scos = Math.cos(stheta);
        let msin = Math.sin(mtheta);
        let mcos = Math.cos(mtheta);
        let hsin = Math.sin(htheta);
        let hcos = Math.cos(htheta);

        // „ÇØ„É™„Ç¢
        context.clearRect(0, 0, 200, 200);

        // Â§ñÊû†
        context.beginPath();
        context.lineWidth = 2;
        context.arc(100, 100, 98, 0, 2 * Math.PI);
        context.closePath();
        context.stroke();

        context.font = 'bold 20px sans-serif';
        context.textAlign = "center";
        context.textBaseline = "bottom";
        context.fillText('UTC', 100, 77);

        // ÁßíÈáù
        context.beginPath();
        context.lineWidth = 1;
        context.moveTo(100 - 15 * ssin, 100 + 15 * scos);
        context.lineTo(100 + 80 * ssin, 100 - 80 * scos);
        context.stroke();

        // Èï∑Èáù
        context.beginPath();
        context.lineWidth = 3;
        context.moveTo(100 - 5 * msin, 100 + 5 * mcos);
        context.lineTo(100 + 90 * msin, 100 - 90 * mcos);
        context.stroke();

        // Áü≠Èáù
        context.beginPath();
        context.lineWidth = 6;
        context.moveTo(100 - 5 * hsin, 100 + 5 * hcos);
        context.lineTo(100 + 60 * hsin, 100 - 60 * hcos);
        context.stroke();
    }

    /* Common Declaration End */

    /* Home View Declaration Start */

    function loadViewHome() {
        loadingStart();

        callViewClosingHandlerIfExist();

        div_contents.innerHTML =
            `<div class="pure-u-1">
    <div id="latest_updates"></div>
</div>`;
        // TODO Registering events

        loadingEnd();
    }

    /* Home View Declaration End */

    /* Block View Declaration Start */

    const MAX_INIT_BLOCK_LIST_ELEMENTS_PER_SIDE = 100;  // This can't be small enough to fit the biggest screen in the world
    const BLOCK_LIST_ELEMENTS_LOAD_N = 20;  // Maximum of this number of block list elements are added each time when scroll change is performed
    const ABOUT_TAG_LIST = ['hash', 'miner', 'difficulty', 'gas_used', 'gas_limit',
        'extra_data', 'nonce', 'sha3_uncles', 'size', 'internal_id'];

    let blocklistInner; // Div element which is is block-list-inner
    let blocklist;      // Div element which id is block-list

    let latestBlockNumber = undefined; // Latest block number known by the client
    let blockListInitialized = false;
    let scrollCheckIntervalId;  // setInterval id of scrollCheck calling
    let scrollAction = false; // Not to do scroll change if events are issued while performing it
    let elementHeight = -1; // Height of one block list element
    let nextTopBlockNum;    // Next block number will be added to the block list on BEGINNING
    let nextBottomBlockNum; // Next block number will be added to the block list on END including a working block

    function loadViewBlock($blockNumber) {
        let content = ['number', $blockNumber, 'all', 'all'];

        loadingStart();

        requestService.connectAndRequest('block', content, function(response) {
            blockRequestCallback(response);
            loadingEnd();
        });
    }

    function blockRequestCallback(response) {
        if (response === false) {
            return;
        }

        let uncles_html = "";
        let transactions_html = "";

        let uncles = response['uncles'];
        for (let i in uncles) {
            uncles_html += `#${uncles[i]['number']}<br>`;
        }

        let transactions = response['transactions'];

        for (let i in transactions) {
            let txValue = new BigNumber(transactions[i]['value']).div(ONE_NUKO);

            transactions_html += `<div class="tx-list-element tx-sending">
                        <span class="tx-list-title">Sending ${txValue} NUKO</span><br>
                        ${transactions[i]['from']} <i class="fa fa-arrow-right" aria-hidden="true"></i> ${transactions[i]['to']}<br>
                        ${transactions[i]['hash']}
                    </div>`;
        }


        let about_html = "";

        for (let i in ABOUT_TAG_LIST) {
            about_html += `<span class="mini-caption">${ABOUT_TAG_LIST[i]}</span>
                            <span class="captioned-text">${response[ABOUT_TAG_LIST[i]]}</span>`;
        }

        div_contents.innerHTML =
            `<div class="pure-g">
            <div id="blockview-left" class="pure-u-1-8">
                <div id="blockview-list">
                    <span class="blockview-list-element">1</span>
                    <span class="blockview-list-element">2</span>
                    <span class="blockview-list-element">3</span>
                    <span class="blockview-list-element">4</span>
                    <span class="blockview-list-element">5</span>
                    <span class="blockview-list-element">6</span>
                    <span class="blockview-list-element">7</span>
                    <span class="blockview-list-element">8</span>
                    <span class="blockview-list-element">9</span>
                    <span class="blockview-list-element">10</span>
                    <span class="blockview-list-element">11</span>
                </div>
            </div>
            <div class="pure-u-7-8">
                <div id="blockview-right">
                    <h1>Block #${response['number']}</h1>
                    <div >
                        <div class="block-time">
                            <canvas id="canvas-block-time-clock" class="block-time-clock" height="200px" width="200px"></canvas>
                        </div>
                        <div class="block-about">
                            ${about_html}
                        </div>
                    </div>
                    <div>
                        <h2>Citing ${response['uncles'].length} Uncle(s)</h2>

                        ${uncles_html}
                    </div>
                    <div>
                        <h2>${response['transactions'].length} Transaction(s)</h2>

                        ${transactions_html}
                    </div>
                </div>
            </div>
        </div>`;

        let cc = document.getElementById('canvas-block-time-clock').getContext('2d');
        drawClock(cc, response['timestamp']);

        blocklistInner = document.getElementById('blockview-list-inner');
        blocklist = document.getElementById('blockview-list');

        blocklist.addEventListener('scroll', scrollEvent);  // Add event listener for block list scroll event

        scrollCheckIntervalId = setInterval(function () {
            console.log("called");
            scrollEvent();
        }, 1000);   // This is for up scroll glitch not for ie fail-safe

        blockNumberStreamService.registerListener('block_list', function (blockNumber) {    // Register listener for real-time block list update
            let beforeLatestBlockNumber = latestBlockNumber;
            latestBlockNumber = new BigNumber(blockNumber);

            if (beforeLatestBlockNumber === undefined) {   // If this was the first message
                /* Initialize block list */

//            fillBlockList(new BigNumber(500));

                fillBlockList(latestBlockNumber.sub(16));

                blockListInitialized = true;    // Block list successfully initialized, now scroll event will be performed
            } else {
                if (latestBlockNumber.comparedTo(beforeLatestBlockNumber) < 0) {
                    /* Block chain reorganization happened (forking) */

                    nextBottomBlockNum = latestBlockNumber.add(1);
                    let i = nextBottomBlockNum;

                    /* Removing list elements who got deleted from the blockchain */
                    while (i.comparedTo(beforeLatestBlockNumber) <= 0) {
                        let rmv = document.getElementById('blockview-list-element-n' + i);
                        rmv.parentNode.removeChild(rmv);
                    }
                } else {

                    if (nextBottomBlockNum.comparedTo(beforeLatestBlockNumber.add(1)) === 0) {  // Latest block are shown
//                let scrollBottom = blocklist.scrollTop === (blocklistInner.clientHeight - blocklist.clientHeight);

                        addToBlockList('beforeEnd', nextBottomBlockNum);
                        nextBottomBlockNum = nextBottomBlockNum.add(1);

//                if (scrollBottom) { // If scroll was max, set max again
//                    blocklist.scrollTop = blocklistInner.clientHeight - blocklist.clientHeight;
//                }
                    }
                }
            }
        });
    }

    function scrollEvent() {  // Add scroll event listener
        if (blockListInitialized && !scrollAction) {
//            scrollAction = true;

            if (blocklist.scrollTop <= elementHeight) {
                /* Add more block elements on top of the list */
                let i;

                for (i = 0; i < BLOCK_LIST_ELEMENTS_LOAD_N; i++) {
                    if (nextTopBlockNum.comparedTo(0) < 0) {  // Already showing the oldest block (#0)
                        break;  // Don't add elements anymore
                    }
                    addToBlockList('afterBegin', nextTopBlockNum);   // Add an element on top of the list
                    nextTopBlockNum = nextTopBlockNum.sub(1);
                }

                if (i !== 0) {  // If elements are added
                    blocklist.scrollTop = elementHeight * (i + 1);  // Set scroll position to where it was, for interval execution
                }
            } else if (blocklist.scrollTop >= blocklistInner.clientHeight - blocklist.clientHeight - elementHeight) {
                /* Add more block elements on bottom of the list */
                for (let i = 0; i < BLOCK_LIST_ELEMENTS_LOAD_N; i++) {
                    if (nextBottomBlockNum.comparedTo(latestBlockNumber.add(1)) > 0) {  // Already showing the latest block + 1
                        break;
                    }

                    addToBlockList('beforeEnd', nextBottomBlockNum);    // Add an element on bottom of the list
                    nextBottomBlockNum = nextBottomBlockNum.add(1);
                }
            }

            scrollAction = false;
        }
    }

    function fillBlockList(blockNumber) {
        blocklistInner.innerHTML = '';  // Clear all elements

        /* Fill block list with initial elements around the blockNumber */

        addToBlockList('beforeEnd', blockNumber);  // Add a center block

        elementHeight = blocklistInner.clientHeight; // Get how much y-space is needed for just one element

        nextTopBlockNum = blockNumber.sub(1);      // Next block number listed BEFORE the center block
        nextBottomBlockNum = blockNumber.add(1);   // Next block number listed AFTER the center block

        let topBlocks = Math.ceil(blocklist.clientHeight / elementHeight) + 1;  // Default value of the amount of elements listed before the center block.
        // Total height should be one element's height higher from the same as the list div height, if this number of elements are stacked

        if (topBlocks > MAX_INIT_BLOCK_LIST_ELEMENTS_PER_SIDE) {    // This stops infinite loop to happen if something went wrong
            topBlocks = MAX_INIT_BLOCK_LIST_ELEMENTS_PER_SIDE;
        }

        let bottomBlocks = topBlocks;   // Both default amount of bottom and top blocks are the same

        if (blockNumber.sub(topBlocks).comparedTo(0) < 0) {  // Check if this exceeds the lower limit of zero (minimum block number)
            topBlocks = blockNumber;    // Think blockNumber as the amount of blocks remaining on top of the center block.
            // This would list all elements from zero to before the center block
        }

        if (blockNumber.add(bottomBlocks).comparedTo(latestBlockNumber.add(1)) > 0) {  // Check if this exceeds the upper limit of latest block number + 1
            bottomBlocks = (latestBlockNumber.add(1)).sub(blockNumber).toNumber();
        }

        /* Most fun part! Add elements to the HTML */

        for (let i = 0; i < topBlocks; i++) {
            addToBlockList('afterBegin', nextTopBlockNum);    // Add element before the center block, watch out for decrement
            nextTopBlockNum = nextTopBlockNum.sub(1);
        }

        for (let i = 0; i < bottomBlocks; i++) {   // Add predecessors of the block
            addToBlockList('beforeEnd', nextBottomBlockNum);
            nextBottomBlockNum = nextBottomBlockNum.add(1);
        }

        /* Try to set scroll bar where the center block become center of the list */

        let yscroll = Math.round(elementHeight * (topBlocks + 0.5) - blocklist.clientHeight / 2);
        let yscrollMax = blocklistInner.clientHeight - blocklist.clientHeight;

        yscroll = Math.max(0, Math.min(yscroll, yscrollMax));   // Cannot scroll to negative or outside from an box

        blocklist.scrollTop = yscroll;  // Set scroll bar
    }

    function addToBlockList(position, blockNumber) {
        blocklistInner.insertAdjacentHTML(position, `<span id="blockview-list-element-n${blockNumber}" class="blockview-list-element">${blockNumber}</span>`);
    }

    /* Block View Declaration End */

    /* Address View Declaration Start */

    function loadViewAddress($address) {
        loadingStart();

        div_contents.innerHTML =
            `<div class="pure-u-1">
    <h1>Address ${address}</h1>
</div>`;

        loadingEnd();
    }

    /* Address View Declaration End */


    loadViewHome();
    loadingEnd();   // Loading finished, close loading screen (loadViewHome close that...)
</script>

<footer>
<div class="pure-g">
<div class="pure-u-1-1">
    2017 Made with ‚ù§ by Cupmouse <a href="https://twitter.com/Cupnmouse" target="_blank"><i style="color: #1da1f2" class="fa fa-twitter" aria-hidden="true"></i></a><br>
    <!-- Just kidding, who the hell loves code. Is it kind of a weird fetish? -->
</div>
</div>
</footer>
</body>
</html>