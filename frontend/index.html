<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Nekonium Block Explorer</title>
    <link rel="stylesheet" href="/css/pure-min.css">
    <link rel="stylesheet" href="/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="icon" type="image/png" href="/adventure_flag_16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="/adventure_flag_32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/adventure_flag_256.png" sizes="256x256">
    <script type="application/javascript" src="/js/Chart.min.js"></script>
    <script type="application/javascript" src="/js/bignumber.min.js"></script>
</head>
<body>
<header>
    <div class="pure-g">
        <div class="pure-u-3-4">
            <a id="title" href="#" onclick="openView(VIEW_HOME)">üö©„Å≠„Åì„ÅÆÊé¢Ê§úÈöä</a>

            <div id="menu" class="pure-menu pure-menu-horizontal">
            <nav>
                <ul class="pure-menu-list">
                    <li class="pure-menu-item">
                        <a onclick="openView(new ViewBlock('number', '170317'))" class="pure-menu-link"><i class="fa fa-th-large" aria-hidden="true"></i> Blocks</a>
                    </li>
                    <li class="pure-menu-item">
                        <a onclick="loadViewTransactionList()" class="pure-menu-link"><i class="fa fa-exchange" aria-hidden="true"></i> Transactions</a>
                    </li>
                    <li class="pure-menu-item pure-menu-disabled">
                        <i class="fa fa-bar-chart" aria-hidden="true"></i> Statistics
                    </li>
                </ul>
            </nav>
            </div>
        </div>
        <div class="pure-u-1-4">
            <div id="mini-statistics" class="pure-g text-selectable">
                <div class="pure-u-1-3">
                    # 1000000
                </div>
                <div class="pure-u-1-3">
                    Diff 150T
                </div>
                <div class="pure-u-1-3">
                    ¬• 1000
                </div>
            </div>
        </div>
        <div class="pure-u-1">
            <form id="search-form" class="pure-form">
                <input type="text" id="search-box" class="pure-input-1" placeholder="Search">
            </form>
            <div id="search-suggestions">
                <ul id="search-suggestion-list">
                </ul>
            </div>
        </div>
    </div>
</header>
<div id="contents-wrapper">
    <!-- Loading screen appears only on view loading -->
    <div id="loading">
        LOADING...
    </div>
    <!-- Inserts an contents in this div tag using Ajax -->
    <div id="contents">


    </div>
</div>

<script type="application/javascript">
    loadingStart(); // Show loading screen (It should already be shown before this)

    /* Common Declaration Start */
    const ONE_NUKO = new BigNumber(10).pow(18);
    const DIFF_PREFIXES = ['', 'K', 'M', 'G', 'T', 'P', 'E'];
    const REGEX_ADDRESS = /^0x[0-9a-fA-F]{40}$/;
    const REGEX_HASH64 = /^0x[0-9a-fA-F]{64}$/;
    const REGEX_NON_NEGATIVE_INT = /^[1-9]\d+$/;

    const div_contents = document.getElementById('contents');
    const search_box = document.getElementById('search-box');
    const search_suggestions = document.getElementById('search-suggestion-list');

    let currentView;    // Current opened view

    const isBlockHash = (hash) => {
        return REGEX_HASH64.test(hash);
    };

    const isTxHash = (hash) => {
        return REGEX_HASH64.test(hash);
    };

    const isNonNegativeInt = (str) => {
        return REGEX_NON_NEGATIVE_INT.test(str);
    };

    const viewSelector = (dir) => {
        const splint = dir.split('/');

        if (splint.length < 1) {
            return VIEW_HOME;
        }

        if (splint[0] === 'block') {
            if (splint[1] === 'hash') {
                if (isBlockHash(splint[2])) {
                    return new ViewBlock('hash', splint[2]);
                } else {
                    return new ViewError("Invalid block hash");
                }
            } else if (splint[1] === 'number' || splint[1] === 'id') {
                // if (!isNaN(splint[1]) && ) {
                //
                // } else {
                //     return new ViewError("Non integer value entered");
                // }
            }

            return new ViewError("Block selection type unknown");
        }

        return new ViewError("Invalid URL");
    };

    class View {

        // Must call loadingEnd in open function
        open() {

        }

        close() {

        }

        beforeClosing() {

        }

        afterClosed() {

        }
    }

    class ViewError extends View {

        constructor(errMsg) {
            super();
            this.errMsg = errMsg;
        }

        open() {
            div_contents.innerHTML = `<h1>Error: ${this.errMsg}</h1>`;

            loadingEnd();
        }
    }

    // Flow: new PaginationControl() -> addWrapper() -> setListener() ----> setPageNum() -> setLastPageNum() -> updateHTML()
    class PaginationControl {

        constructor(limit, initPageNum, initLastPageNum) {
            this.limit = limit;     // Limit of buttons which has page number written on shown

            this.pageNumber = initPageNum;
            this.lastPageNumber = initLastPageNum; // Number of the last page
            this.listener = null;
            this.wrapperDivs = [];  // Initialize an array
        }

        addWrapper(wrapperDiv) {
            this.wrapperDivs.push(wrapperDiv);  // Add new wrapper
            wrapperDiv.addEventListener('click', this._buttonClicked);  // Add click event listener to wrapper
        }

        setListener(listener) {
            this.listener = listener;
        }

        update(pageNumber, lastPageNumber) {
            this.pageNumber = pageNumber;   // Change page number to new one
            this.lastPageNumber = lastPageNumber;   // This one too

            // Update pagination HTML inside of all wrappers

            let pagHTML = this.getHTML();

            for (let i in this.wrapperDivs) {
                this.wrapperDivs[i].innerHTML = pagHTML;
            }
        }

        getHTML() {
            let htmlPag;

            if (this.pageNumber === 1) {
                htmlPag = '<button class="pure-button" disabled>&lt;&lt;</button><button class="pure-button" disabled>&lt;</button>';
            } else {
                htmlPag = '<button class="pure-button">&lt;&lt;</button><button class="pure-button">&lt;</button>';
            }

            // Calculates where page to start

            let pageStart;

            // Can selected page button be centered?
            if (this.lastPageNumber > this.limit) {
                if (this.pageNumber - (this.limit / 2) < 1) {
                    // Don't have enough space left side, start from 1
                    pageStart = 1;
                } else if (this.pageNumber + (this.limit / 2) > this.lastPageNumber) {
                    // Don't have enough space right side
                    pageStart = this.lastPageNumber - this.limit + 1;
                } else {
                    // Have space for both side
                    pageStart = this.pageNumber - Math.floor((this.limit / 2));
                }
            } else {
                // Can show all of page buttons
                pageStart = 1;
            }

            // Generate an button for each page
            let i = pageStart;

            for (; (i < pageStart + this.limit) && (i <= this.lastPageNumber); i++) {
                // Selected button will be shown differently
                if (i === this.pageNumber) {
                    htmlPag += '<button class="pure-button pagination-selected" disabled>' + i + '</button>';
                } else {
                    htmlPag += '<button class="pure-button">' + i + '</button>';
                }
            }

            if (i <= this.lastPageNumber) {
                // Add [...] button if there are more pages after
                htmlPag += '<button class="pure-button" disabled>...</button>';
            }

            if (this.pageNumber === this.lastPageNumber) {
                // Make both button disable
                htmlPag += '<button class="pure-button" disabled>&gt;</button><button class="pure-button" disabled>&gt;&gt;</button>';
            } else {
                htmlPag += '<button class="pure-button">&gt;</button><button class="pure-button">&gt;&gt;</button>';
            }

            return htmlPag;
        }

        _buttonClicked(event) {
            if (event.target.tagName !== 'BUTTON') {
                return;
            }

            switch (event.target.innerText) {
                case '<<':
                    this._callListener(1);  // Go all the way back to page 1
                    break;
                case '<' :
                    this._callListener(this.pageNumber - 1);  // Go back to the previous page
                    break;
                case '>>':
                    this._callListener(this.lastPageNumber); // Go to the last page TODO last page may change, this will not always direct to the 'real' last page
                    break;
                case '>':
                    this._callListener(this.pageNumber + 1);
                    break; // Go to the next page
                default:
                    // Assume all button's innnerText is not malformed, treat it as a target page number
                    this._callListener(parseInt(event.target.innerText, 10)); // Jump to the target page
                    break;
            }
        }

        _callListener(targetPageNumber) {
            this.listener(targetPageNumber);
        }
    }

    class BlockNumberStreamService {
        constructor() {
            this.listeners = new Map();   // Listeners listening to the block number stream
            this.latestNumber = undefined;
        }

        startConnectingAndKeep() {
            this.websocket = new WebSocket('ws://localhost:8080/block-number');

            this.websocket.onclose = function () {  // Try to reconnect if connection is lost
                console.log("Connection closed, retrying");
                setInterval(this.startConnectingAndKeep, 5000);
            };

            let self = this;

            this.websocket.onmessage = function (event) {
                self.latestNumber = event.data;
                self.listeners.forEach((v, k) => v(event.data)); // Call listeners
            };
        }

        registerListener(id, listener) {
            this.listeners.set(id, listener);
            listener(this.latestNumber);
        }

        removeListener(id) {
            this.listeners.delete(id);
        }
    }

    class RequestService {
        constructor() {
            this.connected = false;
            this.connecting = false;
            this.connId = 0;
        }

        connectIfNot() {
            if (this.connected || this.connecting) {
                // Connection is already established or trying to
                return;
            }

            /* Connect to the server */
            this.connecting = true;

            this.callbacks = new Map(); // Create map for storing a nonce and callbacks pair
            this.websocket = new WebSocket('ws://localhost:8080/request');  // Connect to the request websocket server

            let self = this;

            this.websocket.onopen = function () {
                self.connected = true;
                self.connecting = false;
                console.debug("CONNECTION OPENED");
            };
            this.websocket.onclose = function () {
                self.connected = false;
                self.connecting = false;
                console.debug("CONNECTION CLOSED");
            };

            this.websocket.onmessage = function (event) {  // Set onmessage listener
                let response = JSON.parse(event.data); // Parsing from STRING to OBJECT, not otherwise
                let id = response['id'];

                let callback = self.callbacks.get(id);  // Get callback for the id

                callback(response['content']); // Call callback function

                self.callbacks.delete(id);  // Delete callback from the map
            };

            this.nonce = 0; // Initial nonce is 0
            this.connId++;  // Increment connection id
        }

        connectAndRequest(demand, content, callback) {
            this.connectIfNot();

            let wrapped = { // Wrap content
                id: this.nonce,
                demand: demand,
                content: content
            };

            let message = JSON.stringify(wrapped);

            this.callbacks.set(this.nonce, callback);       // Store the callback for response
            this.nonce++;   // Inclement nonce for the next request

            if (this.connected) {
                /* A connection is already established, sending a request immediately */
                this.websocket.send(message);   // Send a request to the server
                console.debug("send#1");
            } else {
                /* Send message to server, retry if connection is not ready */
                let self = this;
                let storedConnId = this.connId;

                let timerId = setInterval(function () {
                    if (self.connId !== storedConnId) {
                        // Connection changed, maybe reestablished
                        clearInterval(timerId); // This function is no longer be called
                        console.debug("discarded#1");

                    } else if (self.connected) {
                        self.websocket.send(message);   // Send to request websocket server
                        clearInterval(timerId); // Stop calling this function
                        console.debug("send#2");

                    } else if (!self.connecting) {
                        // Connection is not established but not trying to
                        clearInterval(timerId); // Guess connection failed
                        console.debug("discarded#2");
                    }
                }, 100);
            }
        }
    }

    const blockNumberStreamService = new BlockNumberStreamService();
    blockNumberStreamService.startConnectingAndKeep();  // Start connecting to the block number streaming service asynchronously
    const requestService = new RequestService();      // Request service will connect to the server in future when it is needed

    let searchStateId = 0;
    let searchTimeoutId;

    search_box.addEventListener('input', function () {  // Registering search box input event
        // Gets the inputted string from the search box
        let search_string = search_box.value;

        if (search_string.length === 0) {
            // todo If search word is empty string, show nothing
        }

        let stored_ssid = ++searchStateId;

        if (searchTimeoutId !== undefined) {
            // Cancel former search wait
            clearTimeout(searchTimeoutId);
        }

        // Wait for the user inputting to settle
        searchTimeoutId = setTimeout(function () {
            requestService.connectAndRequest('search', search_string, function (content) {
                if (searchStateId !== stored_ssid) {
                    // Another search was issued later, discard this
                    console.debug("s_discarded");
                    return;
                }

                let suggestionHTML = "";
                for (let i = 0; i < content.length; i++) {
                    let link_label;

                    switch (content[i][0]) {
                        case 'block_number':        link_label = "Block Number"; break;
                        case 'block_hash':          link_label = "Block"; break;
                        case 'transaction_hash':    link_label = "Transaction"; break;
                        case 'normal_address':      link_label = "Address"; break;
                        case 'contract_address':    link_label = "Contract Address"; break;
                    }

                    link_label += " " + content[i][1];

                    suggestionHTML += `<li>${link_label}</li>`;
                }

                search_suggestions.innerHTML = suggestionHTML;
            });
        }, 250);
    });

    document.getElementById('search-form').addEventListener('submit', function () { // Event listener for search confirm
        alert("is it");
        return false;
    });

    function loadingStart() {
        document.getElementById('loading').style.display = 'block';
    }
    function loadingEnd() {
        document.getElementById('loading').style.display = 'none';
    }

    // Opens a new view
    function openView(newView) {
        let lastView = currentView;

        if (lastView !== undefined) {
            // Close the previous view
            lastView.beforeClosing();
            lastView.close();
            lastView.afterClosed();
        }

        newView.open();

        currentView = newView;
    }

    function drawClock(context, unixEpoch) {
        let date = new Date(unixEpoch * 1000);
        let seconds = date.getUTCSeconds();
        let minutes = date.getUTCMinutes();
        let hours = date.getUTCHours() % 12;

        _drawClock(context, hours, minutes, seconds);
    }

    /**
     * Perform an drawing of current time to the context
     * @param context
     */
    function drawClockNow(context) {
        let date = new Date();
        let seconds = date.getUTCSeconds();
        let minutes = date.getUTCMinutes();
        let hours = date.getUTCHours() % 12;

        _drawClock(context, hours, minutes, seconds);
    }

    function _drawClock(context, hours, minutes, seconds) {
        let stheta = (seconds * 2 * Math.PI) / 60;
        let mtheta = ((minutes + seconds / 60) * 2 * Math.PI) / 60;
        let htheta = ((hours + minutes / 60 + seconds / (60 * 60)) * 2 * Math.PI) / 12;

        let ssin = Math.sin(stheta);
        let scos = Math.cos(stheta);
        let msin = Math.sin(mtheta);
        let mcos = Math.cos(mtheta);
        let hsin = Math.sin(htheta);
        let hcos = Math.cos(htheta);

        // Clear all with rectangle
        context.clearRect(0, 0, 200, 200);

        // Outer frame
        context.beginPath();
        context.lineWidth = 2;
        context.arc(100, 100, 98, 0, 2 * Math.PI);
        context.closePath();
        context.stroke();

        context.font = 'bold 20px sans-serif';
        context.textAlign = "center";
        context.textBaseline = "bottom";
        context.fillText('UTC', 100, 77);

        // Second hand
        context.beginPath();
        context.lineWidth = 1;
        context.moveTo(100 - 15 * ssin, 100 + 15 * scos);
        context.lineTo(100 + 80 * ssin, 100 - 80 * scos);
        context.stroke();

        // Minute hand
        context.beginPath();
        context.lineWidth = 3;
        context.moveTo(100 - 5 * msin, 100 + 5 * mcos);
        context.lineTo(100 + 90 * msin, 100 - 90 * mcos);
        context.stroke();

        // Hour hand
        context.beginPath();
        context.lineWidth = 6;
        context.moveTo(100 - 5 * hsin, 100 + 5 * hcos);
        context.lineTo(100 + 60 * hsin, 100 - 60 * hcos);
        context.stroke();
    }

    function paddingZero(str, size) {
        for (let i = 0; i < size - str.length; i++)
            str = "0" + str;

        return str;
    }

    function formatUTCUnixEpoch(unixEpoch) {
        let date = new Date(unixEpoch * 1000);
        let year = date.getUTCFullYear().toString();
        let month = paddingZero(date.getUTCMonth().toString(), 2);
        let day = paddingZero(date.getUTCDay().toString(), 2);
        let hours = paddingZero(date.getUTCHours().toString(), 2);
        let minutes = paddingZero(date.getUTCMinutes().toString(), 2);
        let seconds = paddingZero(date.getUTCSeconds().toString(), 2);

        return "UTC " + year + "/" + month + "/" + day + " " + hours + ":" + minutes + ":" + seconds;
    }



    /**
     *
     * @param elemId
     * @param pagControl Populate HTML if set
     * @returns {string}
     */
    function genNewPagWrapperHTML(elemId, pagControl = undefined) {
        let cont = '';

        if (pagControl !== undefined) { // No initialize
            cont = pagControl.getHTML();
        }

        return '<div id="' + elemId + '" class="pure-u-1 pure-button-group pagination" role="group">' + cont + '</div>';
    }

    /* Common Declaration End */

    /* Home View Declaration Start */

    class ViewHome extends View {

        open() {
            div_contents.innerHTML =
                `<div class="pure-u-1">
    <div id="latest_updates"></div>
</div>`;
            // TODO Registering events

            loadingEnd();
        }
    }

    const VIEW_HOME = new ViewHome();

    /* Home View Declaration End */

    /* Block List View Declaration Start */

    const BLOCKLIST_PAGINATION_LIMIT = 9;

    class ViewBlockList {

        constructor(pageNumber) {
            this.pageNumber = pageNumber;
        }

        open() {
            // Request to the server

            let self = this;

            requestService.connectAndRequest("block-list", this.pageNumber, function (response) {
                self._requestCallback(response);
                loadingEnd();
            });
        }

        _requestCallback(response) {
            // Generate table content
            let tableContent = this._genTableContent(response[0]);

            // Generate pagination
            let pag = new PaginationControl(BLOCKLIST_PAGINATION_LIMIT, this.pageNumber, response[1]);

            // Replace content
            div_contents.innerHTML = `<div class="pure-g">
            ${genNewPagWrapperHTML('blocklist-pagination-top', pag)}
            <div class="pure-u-1">
                <table id="blocklist-table" class="pure-table pure-table-striped">
                    <thead>
                    <tr><th>#</th><th>Hash</th><th>Miner</th><th>Tx#</th><th>Uncle#</th><th>Forked?</th><th>Id</th></tr>
                    </thead>
                    <tbody>
                    ${tableContent}
                    </tbody>
                </table>
            </div>
            ${genNewPagWrapperHTML('blocklist-pagination-bottom', pag)}
        </div>`;

            pag.addWrapper(document.getElementById('blocklist-pagination-top'));
            pag.addWrapper(document.getElementById('blocklist-pagination-bottom'));

            let self = this;
            pag.setListener(function (pageNumber) {
                self.changePageTo(pageNumber);
            });
        }

        changePageTo(pageNumber) {
            let tableDiv = document.getElementById('blocklist-table');

            // TODO ask for new block list data

            tableDiv.innerHTML = this._genTableContent();
        }

        _genTableContent(blocks) {
            let tableContent = '';

            for (let i in blocks) {
                let blockelm = blocks[i];
                let number = blockelm['number'];
                let hash = blockelm['hash'];
                let miner = blockelm['miner'];
                let internalId = blockelm['internal_id'];
                let txCount = blockelm['tx_count'];
                let uncleCount = blockelm['uncle_count'];
                let forked = blockelm['forked'] ? '<i class="fa fa-code-fork" aria-hidden="true"></i> Forked' : 'On-main';

                tableContent +=
                    `<tr>
                    <td><a href="/block/number/${number}">${number}</a></td>
                    <td><a href="/block/hash/${hash}">${hash}</a></td>
                    <td><a href="/address/${miner}">${miner}</a></td>
                    <td><a href="/block/id/${internalId}">${txCount}</a></td>
                    <td><a href="/block/id/${internalId}">${uncleCount}</a></td>
                    <td>${forked}</td>
                    <td><a href="/block/id/${internalId}">${internalId}</a></td>
                    </tr>`
            }

            return tableContent;
        }
    }

    /* Block List View Declaration End */

    /* Block View Declaration Start */

    const MAX_INIT_BLOCK_LIST_ELEMENTS_PER_SIDE = 100;  // This can't be small enough to fit the biggest screen in the world
    const BLOCK_LIST_ELEMENTS_LOAD_N = 20;  // Maximum of this number of block list elements are added each time when scroll change is performed
    const BLOCK_LIST_BNSS_KEY = 'block_list';

    class ViewBlock extends View {

        constructor(key, value) {
            super();
            this.targetKey = key;
            this.targetValue = value;
            this.blocklistInner = undefined; // Div element which is is block-list-inner
            this.blocklist = undefined;      // Div element which id is block-list

            this.latestBlockNumber = undefined; // Latest block number known by the client
            this.blockListInitialized = false;
            this.scrollCheckIntervalId = undefined;  // setInterval id of scrollCheck calling
            this.scrollAction = false; // Not to do scroll change if events are issued while performing it
            this.elementHeight = -1; // Height of one block list element
            this.nextTopBlockNum = undefined;    // Next block number will be added to the block list on BEGINNING
            this.nextBottomBlockNum = undefined; // Next block number will be added to the block list on END including a working block
        }

        open() {
            let content = [this.targetKey, this.targetValue];

            loadingStart();

            let self = this;

            requestService.connectAndRequest('block', content, function(response) {
                self.blockRequestCallback(response);
                loadingEnd();
            });
        }

        beforeClosing() {
            clearInterval(this.scrollCheckIntervalId);  // Remove scroll check in a interval
            blockNumberStreamService.removeListener(BLOCK_LIST_BNSS_KEY);   // Remove block number listener
        }

        blockRequestCallback(response) {
            if (response === false) {
                return;
            }

            let uncles_html = '';
            let transactions_html = '';

            let uncles = response['uncles'];
            for (let i in uncles) {
                uncles_html += `#${uncles[i][1]}<br>`;
            }

            let divided = new BigNumber(response['difficulty']);
            let humanReadableDiff;
            let prefixIndex = 0;

            while ((divided = divided.div(1000)).comparedTo(1) >= 0) {
                humanReadableDiff = divided;
                prefixIndex++;
            }

            let difficultyFormatted = humanReadableDiff.round(2).toString() + DIFF_PREFIXES[prefixIndex];
            let timestampFormatted = formatUTCUnixEpoch(response['timestamp']);

            div_contents.innerHTML =
                `<div class="pure-g">
            <div id="blockview-left" class="pure-u-1-4">
                <div id="blockview-list">
                    <div id="blockview-list-inner">

                    </div>
                </div>
            </div>
            <div class="pure-u-3-4">
                <div id="blockview-right">
                    <h1>Block #${response['number']}</h1>
                    <div >
                        <div class="block-time">
                            <canvas id="canvas-block-time-clock" class="block-time-clock"
                                title="${timestampFormatted}"
                                height="200px" width="200px"></canvas>
                        </div>
                        <div class="block-about">
                            <span class="mini-caption">Hash</span><span class="captioned-text">${response['hash']}</span>
                            <span class="mini-caption">Miner</span><span class="captioned-text">${response['miner']}</span>
                            <span class="mini-caption">Difficulty</span><span class="captioned-text" title="${response['difficulty']}">${difficultyFormatted}</span>
                            <span class="mini-caption">Gas</span>
                            <span class="captioned-text">
                            <span title="The amount of gas used in this block">${response['gas_used']}</span> / <span title="The upper limit of gas could be used in this block">${response['gas_limit']}</span>
                            </span>
                            <span class="mini-caption">Extra Data</span><span class="captioned-text">${response['extra_data']}</span>
                            <span class="mini-caption">Nonce</span><span class="captioned-text">${response['nonce']}</span>
                            <span class="mini-caption">Size</span><span class="captioned-text">${response['size']} bytes</span>
                            <span class="mini-caption">Internal Id</span><span class="captioned-text">${response['internal_id']}</span>
                        </div>
                    </div>
                    <h2>${response['transactions'].length} Transaction(s)</h2>
                    <div>
                        <h2>Citing ${response['uncles'].length} Uncle(s)</h2>

                        ${uncles_html}
                    </div>
                </div>
            </div>
        </div>`;

            let cc = document.getElementById('canvas-block-time-clock').getContext('2d');
            drawClock(cc, response['timestamp']);

            this.blocklistInner = document.getElementById('blockview-list-inner');
            this.blocklist = document.getElementById('blockview-list');

            let self = this;

            this.blocklist.addEventListener('scroll', function () {
                self.scrollEvent(); // Functions in class doesn't have real 'value' have to call them from a function
            });  // Add event listener for block list scroll event

            this.scrollCheckIntervalId = setInterval(function () {
                console.log("called");
                self.scrollEvent();
            }, 1000);   // This is for up scroll glitch not for ie fail-safe

            blockNumberStreamService.registerListener(BLOCK_LIST_BNSS_KEY, function (blockNumber) {    // Register listener for real-time block list update
                let beforeLatestBlockNumber = self.latestBlockNumber;
                self.latestBlockNumber = new BigNumber(blockNumber);

                if (beforeLatestBlockNumber === undefined) {   // If this was the first message
                    /* Initialize block list */

                    self.fillBlockList(new BigNumber(response['number']));

                    self.blockListInitialized = true;    // Block list successfully initialized, now scroll event will be performed
                } else {
                    if (self.latestBlockNumber.comparedTo(beforeLatestBlockNumber) < 0) {
                        /* Block chain reorganization happened (forking) */

                        self.nextBottomBlockNum = self.latestBlockNumber.add(1);
                        let i = self.nextBottomBlockNum;

                        /* Removing list elements who got deleted from the blockchain */
                        while (i.comparedTo(beforeLatestBlockNumber) <= 0) {
                            let rmv = document.getElementById('blockview-list-element-n' + i);
                            rmv.parentNode.removeChild(rmv);
                        }
                    } else {

                        if (self.nextBottomBlockNum.comparedTo(beforeLatestBlockNumber.add(1)) === 0) {  // Latest block are shown
//                let scrollBottom = blocklist.scrollTop === (blocklistInner.clientHeight - blocklist.clientHeight);

                            addToBlockList('beforeEnd', self.nextBottomBlockNum);
                            self.nextBottomBlockNum = self.nextBottomBlockNum.add(1);

//                if (scrollBottom) { // If scroll was max, set max again
//                    blocklist.scrollTop = blocklistInner.clientHeight - blocklist.clientHeight;
//                }
                        }
                    }
                }
            });
        }

        scrollEvent() {  // Add scroll event listener
            if (this.blockListInitialized && !this.scrollAction) {
//            scrollAction = true;

                if (this.blocklist.scrollTop <= this.elementHeight) {
                    /* Add more block elements on top of the list */
                    let i;

                    for (i = 0; i < BLOCK_LIST_ELEMENTS_LOAD_N; i++) {
                        if (this.nextTopBlockNum.comparedTo(0) < 0) {  // Already showing the oldest block (#0)
                            break;  // Don't add elements anymore
                        }
                        this.addToBlockList('afterBegin', this.nextTopBlockNum);   // Add an element on top of the list
                        this.nextTopBlockNum = this.nextTopBlockNum.sub(1);
                    }

                    if (i !== 0) {  // If elements are added
                        this.blocklist.scrollTop = this.elementHeight * (i + 1);  // Set scroll position to where it was, for interval execution
                    }
                } else if (this.blocklist.scrollTop >= this.blocklistInner.clientHeight - this.blocklist.clientHeight - this.elementHeight) {
                    /* Add more block elements on bottom of the list */
                    for (let i = 0; i < BLOCK_LIST_ELEMENTS_LOAD_N; i++) {
                        if (this.nextBottomBlockNum.comparedTo(this.latestBlockNumber.add(1)) > 0) {  // Already showing the latest block + 1
                            break;
                        }

                        this.addToBlockList('beforeEnd', this.nextBottomBlockNum);    // Add an element on bottom of the list
                        this.nextBottomBlockNum = this.nextBottomBlockNum.add(1);
                    }
                }

                this.scrollAction = false;
            }
        }

        fillBlockList(blockNumber) {
            this.blocklistInner.innerHTML = '';  // Clear all elements

            /* Fill block list with initial elements around the blockNumber */

            this.addToBlockList('beforeEnd', blockNumber);  // Add a center block

            this.elementHeight = this.blocklistInner.clientHeight; // Get how much y-space is needed for just one element

            this.nextTopBlockNum = blockNumber.sub(1);      // Next block number listed BEFORE the center block
            this.nextBottomBlockNum = blockNumber.add(1);   // Next block number listed AFTER the center block

            let topBlocks = Math.ceil(this.blocklist.clientHeight / this.elementHeight) + 1;  // Default value of the amount of elements listed before the center block.
            // Total height should be one element's height higher from the same as the list div height, if this number of elements are stacked

            if (topBlocks > MAX_INIT_BLOCK_LIST_ELEMENTS_PER_SIDE) {    // This stops infinite loop to happen if something went wrong
                topBlocks = MAX_INIT_BLOCK_LIST_ELEMENTS_PER_SIDE;
            }

            let bottomBlocks = topBlocks;   // Both default amount of bottom and top blocks are the same

            if (blockNumber.sub(topBlocks).comparedTo(0) < 0) {  // Check if this exceeds the lower limit of zero (minimum block number)
                topBlocks = blockNumber;    // Think blockNumber as the amount of blocks remaining on top of the center block.
                // This would list all elements from zero to before the center block
            }

            if (blockNumber.add(bottomBlocks).comparedTo(this.latestBlockNumber.add(1)) > 0) {  // Check if this exceeds the upper limit of latest block number + 1
                bottomBlocks = (this.latestBlockNumber.add(1)).sub(blockNumber).toNumber();
            }

            /* Most fun part! Add elements to the HTML */

            for (let i = 0; i < topBlocks; i++) {
                this.addToBlockList('afterBegin', this.nextTopBlockNum);    // Add element before the center block, watch out for decrement
                this.nextTopBlockNum = this.nextTopBlockNum.sub(1);
            }

            for (let i = 0; i < bottomBlocks; i++) {   // Add predecessors of the block
                this.addToBlockList('beforeEnd', this.nextBottomBlockNum);
                this.nextBottomBlockNum = this.nextBottomBlockNum.add(1);
            }

            /* Try to set scroll bar where the center block become center of the list */

            let yscroll = Math.round(this.elementHeight * (topBlocks + 0.5) - this.blocklist.clientHeight / 2);
            let yscrollMax = this.blocklistInner.clientHeight - this.blocklist.clientHeight;

            yscroll = Math.max(0, Math.min(yscroll, yscrollMax));   // Cannot scroll to negative or outside from an box

            this.blocklist.scrollTop = yscroll;  // Set scroll bar
        }

        addToBlockList(position, blockNumber) {
            this.blocklistInner.insertAdjacentHTML(position, `<span id="blockview-list-element-n${blockNumber}" class="blockview-list-element">${blockNumber}</span>`);
        }
    }

    /* Block View Declaration End */

    /* Address View Declaration Start */

    function loadViewAddress($address) {
        loadingStart();

        div_contents.innerHTML =
            `<div class="pure-u-1">
    <h1>Address ${address}</h1>
</div>`;

        loadingEnd();
    }

    /* Address View Declaration End */



    viewSelector(location.pathname.substr(1));
    loadingEnd();   // Loading finished, close loading screen (loadViewHome close that...)
</script>

<footer>
<div class="pure-g">
<div class="pure-u-1-1">
    2017-2018 Made with ‚ù§ by Cupmouse <a href="https://twitter.com/Cupnmouse" target="_blank"><i style="color: #1da1f2" class="fa fa-twitter" aria-hidden="true"></i></a><br>
    <!-- Just kidding, who the hell loves code. Is it kind of a weird fetish? -->
</div>
</div>
</footer>
</body>
</html>