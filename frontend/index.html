<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Nekonium Block Explorer</title>
    <link rel="stylesheet" href="/css/pure-min.css">
    <link rel="stylesheet" href="/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="icon" type="image/png" href="/adventure_flag_16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="/adventure_flag_32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/adventure_flag_256.png" sizes="256x256">
    <script type="application/javascript" src="/js/Chart.min.js"></script>
    <script type="application/javascript" src="/js/bignumber.min.js"></script>
    <script type="application/javascript" src="/js/blockies.min.js"></script>
</head>
<body>
<header>
    <div class="pure-g">
        <div class="pure-u-3-4">
            <a id="title" href="/">üö©„Å≠„Åì„ÅÆÊé¢Ê§úÈöä</a>

            <div id="menu" class="pure-menu pure-menu-horizontal">
            <nav>
                <ul class="pure-menu-list">
                    <li class="pure-menu-item">
                        <a href="/blocks" class="pure-menu-link"><i class="fa fa-th-large" aria-hidden="true"></i> Blocks</a>
                    </li>
                    <li class="pure-menu-item">
                        <a href="/transactions" class="pure-menu-link"><i class="fa fa-exchange" aria-hidden="true"></i> Transactions</a>
                    </li>
                    <li class="pure-menu-item pure-menu-disabled">
                        <i class="fa fa-bar-chart" aria-hidden="true"></i> Statistics
                    </li>
                </ul>
            </nav>
            </div>
        </div>
        <div class="pure-u-1-4">
            <div id="mini-statistics" class="pure-g text-selectable">
                <div class="pure-u-1-3">
                    # 1000000
                </div>
                <div class="pure-u-1-3">
                    Diff 150T
                </div>
                <div class="pure-u-1-3">
                    ¬• 1000
                </div>
            </div>
        </div>
        <div class="pure-u-1">
            <form id="search-form" class="pure-form">
                <input type="text" id="search-box" class="pure-input-1" placeholder="Search">
            </form>
            <div id="search-suggestions">
                <ul id="search-suggestion-list">
                </ul>
            </div>
        </div>
    </div>
</header>
<div id="contents-wrapper">
    <!-- Loading screen appears only on view loading -->
    <div id="loading">
        LOADING...
    </div>
    <!-- Inserts an contents in this div tag using Ajax -->
    <div id="contents">


    </div>
</div>

<script type="application/javascript">
    /* Common Declaration Start */
    const SITE_TITLE = 'Neko no tankentai';

    const div_contents = document.getElementById('contents');
    const search_box = document.getElementById('search-box');
    const search_suggestions = document.getElementById('search-suggestion-list');

    // Type check

    const REGEX_ADDRESS = /^0x[0-9a-fA-F]{40}$/;
    const REGEX_HASH64 = /^0x[0-9a-fA-F]{64}$/;
    const REGEX_NON_NEGATIVE_INT = /^[1-9]\d+$/;

    const isBlockHash = (hash) => {
        return REGEX_HASH64.test(hash);
    };

    const isTxHash = (hash) => {
        return REGEX_HASH64.test(hash);
    };

    const isAddressHash = (hash) => {
        return REGEX_ADDRESS.test(hash);
    };

    const isNonNegativeInt = (str) => {
        return REGEX_NON_NEGATIVE_INT.test(str);
    };

    // UI and human friendly values

    const ONE_NUKO = new BigNumber(10).pow(18);
    const DIFF_PREFIXES = ['', 'K', 'M', 'G', 'T', 'P', 'E'];

    // Flow: new PaginationControl() -> addWrapper() -> setListener() ----> setPageNum() -> setLastPageNum() -> updateHTML()
    class PaginationControl {

        constructor(limit, initPageNum, initLastPageNum) {
            this.limit = limit;     // Limit of buttons which has page number written on shown

            this.pageNumber = initPageNum;
            this.lastPageNumber = initLastPageNum; // Number of the last page
            this.listener = null;
            this.wrapperDivs = [];  // Initialize an array
        }

        addWrapper(wrapperDiv) {
            this.wrapperDivs.push(wrapperDiv);  // Add new wrapper

            let self = this;

            wrapperDiv.addEventListener('click', function (event) {
                self._buttonClicked(event);
            });  // Add click event listener to wrapper
        }

        setListener(listener) {
            this.listener = listener;
        }

        update(pageNumber, lastPageNumber) {
            this.pageNumber = pageNumber;   // Change page number to new one
            this.lastPageNumber = lastPageNumber;   // This one too

            // Update pagination HTML inside of all wrappers

            let pagHTML = this.getHTML();

            for (let i in this.wrapperDivs) {
                this.wrapperDivs[i].innerHTML = pagHTML;
            }
        }

        getHTML() {
            let htmlPag;

            if (this.pageNumber === 1) {
                htmlPag = '<button class="pure-button" disabled>&lt;&lt;</button><button class="pure-button" disabled>&lt;</button>';
            } else {
                htmlPag = '<button class="pure-button">&lt;&lt;</button><button class="pure-button">&lt;</button>';
            }

            // Calculates where page to start

            let pageStart;

            // Can selected page button be centered?
            if (this.lastPageNumber > this.limit) {
                if (this.pageNumber - (this.limit / 2) < 1) {
                    // Don't have enough space left side, start from 1
                    pageStart = 1;
                } else if (this.pageNumber + (this.limit / 2) > this.lastPageNumber) {
                    // Don't have enough space right side
                    pageStart = this.lastPageNumber - this.limit + 1;
                } else {
                    // Have space for both side
                    pageStart = this.pageNumber - Math.floor((this.limit / 2));
                }
            } else {
                // Can show all of page buttons
                pageStart = 1;
            }

            // Generate an button for each page
            let i = pageStart;

            for (; (i < pageStart + this.limit) && (i <= this.lastPageNumber); i++) {
                // Selected button will be shown differently
                if (i === this.pageNumber) {
                    htmlPag += '<button class="pure-button pagination-selected" disabled>' + i + '</button>';
                } else {
                    htmlPag += '<button class="pure-button">' + i + '</button>';
                }
            }

            if (i <= this.lastPageNumber) {
                // Add [...] button if there are more pages after
                htmlPag += '<button class="pure-button" disabled>...</button>';
            }

            if (this.pageNumber === this.lastPageNumber) {
                // Make both button disable
                htmlPag += '<button class="pure-button" disabled>&gt;</button><button class="pure-button" disabled>&gt;&gt;</button>';
            } else {
                htmlPag += '<button class="pure-button">&gt;</button><button class="pure-button">&gt;&gt;</button>';
            }

            return htmlPag;
        }

        _buttonClicked(event) {
            if (event.target.tagName !== 'BUTTON') {
                return;
            }

            switch (event.target.innerText) {
                case '<<':
                    this._callListener(1);  // Go all the way back to page 1
                    break;
                case '<' :
                    this._callListener(this.pageNumber - 1);  // Go back to the previous page
                    break;
                case '>>':
                    this._callListener(this.lastPageNumber); // Go to the last page TODO last page may change, this will not always direct to the 'real' last page
                    break;
                case '>':
                    this._callListener(this.pageNumber + 1);
                    break; // Go to the next page
                default:
                    // Assume all button's innnerText is not malformed, treat it as a target page number
                    this._callListener(parseInt(event.target.innerText, 10)); // Jump to the target page
                    break;
            }
        }

        _callListener(targetPageNumber) {
            this.listener(targetPageNumber);
        }
    }

    /**
     *
     * @param elemId
     * @param pagControl Populate HTML if set
     * @returns {string}
     */
    const genNewPagWrapperHTML = (elemId, pagControl = undefined) => {
        let cont = '';

        if (pagControl !== undefined) { // No initialize
            cont = pagControl.getHTML();
        }

        return '<div id="' + elemId + '" class="pure-u-1 pure-button-group pagination" role="group">' + cont + '</div>';
    };

    const shorten = (string, length, suffix = '...') => {
        if (string.length < length - suffix.length) {
            // Shorter than expected
            return string;
        }

        return string.substr(0, length - suffix.length).concat(suffix);
    };

    const paddingZero = (str, size) => {
        for (let i = 0; i < size - str.length; i++)
            str = "0" + str;

        return str;
    };

    const formatUTCUnixEpoch = (unixEpoch) => {
        const date = new Date(unixEpoch * 1000);
        const year = date.getUTCFullYear().toString();
        const month = paddingZero((date.getUTCMonth() + 1).toString(), 2);  // Note: Jan === 0 weird
        const day = paddingZero(date.getUTCDate().toString(), 2);
        const hours = paddingZero(date.getUTCHours().toString(), 2);
        const minutes = paddingZero(date.getUTCMinutes().toString(), 2);
        const seconds = paddingZero(date.getUTCSeconds().toString(), 2);

        return `UTC ${year}/${month}/${day} ${hours}:${minutes}:${seconds}`;
    };

    const humanizeSec = (sec) => {
        if (sec === 1) {
            return '1 second';
        } else if (sec < 60) {
            return `${sec} seconds`
        } else if (sec < 60 * 60) {
            const mins = Math.floor(sec / 60);

            // Difference if only suffixed by 's'
            if (mins === 1) {
                return '1 minute';
            } else {
                return `${mins} minutes`;
            }
        } else if (sec < 60 * 60 * 24) {
            const hours = Math.floor(sec / 60 / 60);

            if (hours === 1) {
                return '1 hour';
            } else {
                return `${hours} hours`;
            }
        } else {
            // When difference is over a day, count in days

            const days = Math.floor(sec / 60 /60 / 24);

            if (days === 1) {
                return '1 day';
            } else {
                return `${days} days`;
            }
        }
    };

    const calcDiffUnixEpochFromNow = (unixEpoch) => {
        return Math.floor(Date.now() / 1000) - unixEpoch;   // Date.now() returns UTC time
    };

    const humanizeUnixEpochDiffFromNow = (unixEpoch) => {
        const diff = calcDiffUnixEpochFromNow(unixEpoch);   // Difference but not absolute, negative value means future from now

        if (diff === 0) {
            return 'now';   // Just now !!!
        } else if (diff > 0) {
            return `${humanizeSec(diff)} ago`;  // Things happened earlier
        } else {
            // diff < 0
            return `${humanizeSec(diff)} later`;    // Things that will happen (!!!)
        }
    };

    const genAddressIconCanvas = (address) => {
        let option = {
            seed: address,
            scale: 5,
            size: 10
        };

        return blockies.create(option);
    };

    const _drawClock = (context, hours, minutes, seconds) => {
        let stheta = (seconds * 2 * Math.PI) / 60;
        let mtheta = ((minutes + seconds / 60) * 2 * Math.PI) / 60;
        let htheta = ((hours + minutes / 60 + seconds / (60 * 60)) * 2 * Math.PI) / 12;

        let ssin = Math.sin(stheta);
        let scos = Math.cos(stheta);
        let msin = Math.sin(mtheta);
        let mcos = Math.cos(mtheta);
        let hsin = Math.sin(htheta);
        let hcos = Math.cos(htheta);

        // Clear all with rectangle
        context.clearRect(0, 0, 200, 200);

        // Outer frame
        context.beginPath();
        context.lineWidth = 2;
        context.arc(100, 100, 98, 0, 2 * Math.PI);
        context.closePath();
        context.stroke();

        context.font = 'bold 20px sans-serif';
        context.textAlign = "center";
        context.textBaseline = "bottom";
        context.fillText('UTC', 100, 77);

        // Second hand
        context.beginPath();
        context.lineWidth = 1;
        context.moveTo(100 - 15 * ssin, 100 + 15 * scos);
        context.lineTo(100 + 80 * ssin, 100 - 80 * scos);
        context.stroke();

        // Minute hand
        context.beginPath();
        context.lineWidth = 3;
        context.moveTo(100 - 5 * msin, 100 + 5 * mcos);
        context.lineTo(100 + 90 * msin, 100 - 90 * mcos);
        context.stroke();

        // Hour hand
        context.beginPath();
        context.lineWidth = 6;
        context.moveTo(100 - 5 * hsin, 100 + 5 * hcos);
        context.lineTo(100 + 60 * hsin, 100 - 60 * hcos);
        context.stroke();
    };

    const drawClock = (context, unixEpoch) => {
        let date = new Date(unixEpoch * 1000);
        let seconds = date.getUTCSeconds();
        let minutes = date.getUTCMinutes();
        let hours = date.getUTCHours() % 12;

        _drawClock(context, hours, minutes, seconds);
    };

    /**
     * Perform an drawing of current time to the context
     * @param context
     */
    const drawClockNow = (context) => {
        let date = new Date();
        let seconds = date.getUTCSeconds();
        let minutes = date.getUTCMinutes();
        let hours = date.getUTCHours() % 12;

        _drawClock(context, hours, minutes, seconds);
    };

    // Networking

    class BlockNumberStreamService {
        constructor() {
            this.listeners = new Map();   // Listeners listening to the block number stream
            this.latestNumber = undefined;
        }

        startConnectingAndKeep() {
            this.websocket = new WebSocket('ws://localhost:8080/block-number');

            this.websocket.onclose = function () {  // Try to reconnect if connection is lost
                console.log("Connection closed, retrying");
                setInterval(this.startConnectingAndKeep, 5000);
            };

            let self = this;

            this.websocket.onmessage = function (event) {
                self.latestNumber = event.data;
                self.listeners.forEach((v, k) => v(event.data)); // Call listeners
            };
        }

        registerListener(id, listener) {
            this.listeners.set(id, listener);
            listener(this.latestNumber);
        }

        removeListener(id) {
            this.listeners.delete(id);
        }
    }

    class RequestService {
        constructor() {
            this.connected = false;
            this.connecting = false;
            this.connId = 0;
        }

        connectIfNot() {
            if (this.connected || this.connecting) {
                // Connection is already established or trying to
                return;
            }

            /* Connect to the server */
            this.connecting = true;

            this.callbacks = new Map(); // Create map for storing a nonce and callbacks pair
            this.websocket = new WebSocket('ws://localhost:8080/request');  // Connect to the request websocket server

            let self = this;

            this.websocket.onopen = function () {
                self.connected = true;
                self.connecting = false;
                console.debug("CONNECTION OPENED");
            };
            this.websocket.onclose = function () {
                self.connected = false;
                self.connecting = false;
                console.debug("CONNECTION CLOSED");
            };

            this.websocket.onmessage = function (event) {  // Set onmessage listener
                let response = JSON.parse(event.data); // Parsing from STRING to OBJECT, not otherwise
                let id = response['id'];

                let callback = self.callbacks.get(id);  // Get callback for the id

                callback(response['content']); // Call callback function

                self.callbacks.delete(id);  // Delete callback from the map
            };

            this.nonce = 0; // Initial nonce is 0
            this.connId++;  // Increment connection id
        }

        connectAndRequest(demand, content, callback) {
            this.connectIfNot();

            let wrapped = { // Wrap content
                id: this.nonce,
                demand: demand,
                content: content
            };

            let message = JSON.stringify(wrapped);

            this.callbacks.set(this.nonce, callback);       // Store the callback for response
            this.nonce++;   // Inclement nonce for the next request

            if (this.connected) {
                /* A connection is already established, sending a request immediately */
                this.websocket.send(message);   // Send a request to the server
                console.debug("send#1");
            } else {
                /* Send message to server, retry if connection is not ready */
                let self = this;
                let storedConnId = this.connId;

                let timerId = setInterval(function () {
                    if (self.connId !== storedConnId) {
                        // Connection changed, maybe reestablished
                        clearInterval(timerId); // This function is no longer be called
                        console.debug("discarded#1");

                    } else if (self.connected) {
                        self.websocket.send(message);   // Send to request websocket server
                        clearInterval(timerId); // Stop calling this function
                        console.debug("send#2");

                    } else if (!self.connecting) {
                        // Connection is not established but not trying to
                        clearInterval(timerId); // Guess connection failed
                        console.debug("discarded#2");
                    }
                }, 100);
            }
        }
    }

    const blockNumberStreamService = new BlockNumberStreamService();
    blockNumberStreamService.startConnectingAndKeep();  // Start connecting to the block number streaming service asynchronously
    const requestService = new RequestService();      // Request service will connect to the server in future when it is needed

    // Search box

    let searchStateId = 0;
    let searchTimeoutId;

    search_box.addEventListener('input', function () {
        // Registering search box input event

        // Gets the inputted string from the search box
        let search_string = search_box.value;

        if (search_string.length === 0) {
            // todo If search word is empty string, show nothing
        }

        let stored_ssid = ++searchStateId;

        if (searchTimeoutId !== undefined) {
            // Cancel former search wait
            clearTimeout(searchTimeoutId);
        }

        // Wait for the user inputting to settle
        searchTimeoutId = setTimeout(function () {
            requestService.connectAndRequest('search', search_string, function (content) {
                if (searchStateId !== stored_ssid) {
                    // Another search was issued later, discard this
                    console.debug("s_discarded");
                    return;
                }

                let suggestionHTML = "";
                for (let i = 0; i < content.length; i++) {
                    let link_label;

                    switch (content[i][0]) {
                        case 'block_number':        link_label = "Block Number"; break;
                        case 'block_hash':          link_label = "Block"; break;
                        case 'transaction_hash':    link_label = "Transaction"; break;
                        case 'normal_address':      link_label = "Address"; break;
                        case 'contract_address':    link_label = "Contract Address"; break;
                    }

                    link_label += " " + content[i][1];

                    suggestionHTML += `<li>${link_label}</li>`;
                }

                search_suggestions.innerHTML = suggestionHTML;
            });
        }, 250);
    });

    document.getElementById('search-form').addEventListener('submit', function (event) { // Event listener for search confirm
        event.preventDefault();
        alert("is it");
        return false;
    });

    // View deceleration

    let currentView;    // Current opened view

    class View {

        // Must call loadingEnd in open function
        open() {}

        close() {}

        beforeClosing() {}

        afterClosed() {}

        getTitle() {}
    }

    class ViewError extends View {

        constructor(errMsg) {
            super();
            this.errMsg = errMsg;
        }

        open() {
            div_contents.innerHTML = `<h1>Error: ${this.errMsg}</h1>`;

            loadingEnd();
        }

        getTitle() {
            return 'Error';
        }
    }

    // Opens a new view
    const openView = (newView) => {
        loadingStart(); // TODO weird placement

        let lastView = currentView;

        if (lastView !== undefined) {
            // Close the previous view
            lastView.beforeClosing();
            lastView.close();
            lastView.afterClosed();
        }

        newView.open();

        currentView = newView;
    };

    // Page transitions

    const selectView = (path) => {
        if (path === '/' || path === '') {
            // Returns home view
            return VIEW_HOME;
        }

        // Split string in array
        const splint = path.split('/');

        if (splint[0] === 'block' && splint.length === 3) {
            if (splint[1] === 'hash') {
                if (!isBlockHash(splint[2])) {
                    return new ViewError('Invalid block hash');
                }

                return new ViewBlock('hash', splint[2]);
            } else if (splint[1] === 'number') {
                let fl = parseFloat(splint[2]);

                if (!isNaN(splint[2]) && Number.isInteger(fl)) {
                    let it = parseInt(splint[2]);

                    return new ViewBlock('number', it.toString(10));

                } else {
                    return new ViewError('Non integer value entered');
                }
            }

            return new ViewError('Block selection type unknown');
        } else if (splint[0] === 'tx' && splint.length === 3) {
            if (splint[1] === 'hash') {
                if (isTxHash(splint[2])) {
                    // TODO
                }
            }
        } else if (splint[0] === 'address' && splint.length === 3) {
            if (splint[1] === 'hash') {
                if (!isAddressHash(splint[2])) {
                    throw new ViewError('Invalid address hash');
                }

                return new ViewAddress('hash', splint[2]);
            }

            throw new ViewError('Address selection type unknown')
        } else if (splint[0] === 'blocks' && splint.length === 1) {
            return new ViewBlockList(1);
        } else if (splint[0] === 'transactions' && splint.length === 1) {
        }

        return new ViewError('Invalid URL');
    };

    const transitView = (path, makeHistory) => {
        let selectedView = selectView(path.substr(1));

        openView(selectedView);

        const viewTitle = selectedView.getTitle();

        if (makeHistory) {
            history.pushState(path, viewTitle, path); // Add new history for browser. This will change url in the bar
        }

        document.title = `${viewTitle} | ${SITE_TITLE}`; // Change the page title to view title
    };

    const addAllAnchorsEvent = (node) => {
        let anchors = node.querySelectorAll('a');

        if (anchors === null) {
            return; // There was no anchors
        }

        for (let link of anchors) {
            link.addEventListener('click', function (event) {
                event.preventDefault(); // This would prevent browser to actually move to target url

                const href = event.target.getAttribute('href');
                transitView(href, true);
            });
        }
    };

    // Listening to popstate event makes transition to happen when browser's history button is pressed
    window.addEventListener('popstate', event => {
        transitView(event.state, false);
    });

    // Loading screens

    const loadingStart = () => {
        document.getElementById('loading').style.display = 'block';
    };

    const loadingEnd = () => {
        document.getElementById('loading').style.display = 'none';
    };

    /* Common Declaration End */

    /* Home View Declaration Start */

    class ViewHome extends View {

        open() {
            div_contents.innerHTML =
                `<div class="pure-u-1">
üêæWIPüêæ
    <div id="latest_updates"></div>
</div>`;
            // TODO Registering events

            loadingEnd();
        }

        getTitle() {
            return 'Home';
        }
    }

    const VIEW_HOME = new ViewHome();

    /* Home View Declaration End */

    /* Block List View Declaration Start */

    const BLOCKLIST_PAGINATION_LIMIT = 9;

    class ViewBlockList extends View {

        constructor(pageNumber) {
            super();
            this.pageNumber = pageNumber;
            this.pag = null;    // Pagination controller
        }

        getTitle() {
            return 'Block List';
        }

        open() {
            // Request to the server

            let self = this;

            // TODO change this using `await`
            requestService.connectAndRequest("block-list", ['page', this.pageNumber], function (response) {
                self._requestCallback(response);
                loadingEnd();
            });
        }

        _requestCallback(response) {
            // Generate table content
            let tableContent = this._genTableContent(response[0]);

            // Generate pagination
            this.pag = new PaginationControl(BLOCKLIST_PAGINATION_LIMIT, this.pageNumber, response[1]);

            // Replace content
            div_contents.innerHTML = `<div class="pure-g">
            ${genNewPagWrapperHTML('blocklist-pagination-top', this.pag)}
            <div class="pure-u-1">
                <table id="blocklist-table" class="pure-table pure-table-striped">
                    <thead>
                    <tr><th>#</th><th>Hash</th><th>Miner</th><th>Tx#</th><th>Uncle#</th><th>Forked?</th></tr>
                    </thead>
                    <tbody>
                    ${tableContent}
                    </tbody>
                </table>
            </div>
            ${genNewPagWrapperHTML('blocklist-pagination-bottom', this.pag)}
        </div>`;

            // Setup pagination

            this.pag.addWrapper(document.getElementById('blocklist-pagination-top'));
            this.pag.addWrapper(document.getElementById('blocklist-pagination-bottom'));

            let self = this;
            this.pag.setListener(function (pageNumber) {
                self.changePageTo(pageNumber);
            });

            // Add all generated link event listener
            addAllAnchorsEvent(div_contents);
        }

        changePageTo(pageNumber) {
            loadingStart();

            let tableDiv = document.querySelector('#blocklist-table tbody');

            let self = this;

            requestService.connectAndRequest('block-list', ['page', pageNumber], function (response) {
                tableDiv.innerHTML = self._genTableContent(response[0]);
                self.pag.update(pageNumber, response[1]);

                loadingEnd();
            });
        }

        _genTableContent(blocks) {
            let tableContent = '';

            for (let i in blocks) {
                const blockelm = blocks[i];
                const id = blockelm[0];
                const number = blockelm[1];
                const hash = blockelm[2];
                const miner = blockelm[3];
                const txCount = blockelm[4];
                const uncleCount = blockelm[5];
                let forked;

                if (blockelm[5]) {
                    tableContent +=
                        `<tr>
                    <td>${number}</td>
                    <td><a href="/block/hash/${hash}">${shorten(hash, 12)}</a></td>
                    <td><a href="/address/hash/${miner}">${shorten(miner, 25)}</a></td>
                    <td><a href="/block/id/${id}/txs">${txCount}</a></td>
                    <td><a href="/block/id/${id}/mined">${uncleCount}</a></td>
                    <td><i class="fa fa-code-fork" aria-hidden="true"></i></td>
                    </tr>`;
                } else {
                    tableContent +=
                        `<tr>
                    <td><a href="/block/number/${number}">${number}</a></td>
                    <td><a href="/block/hash/${hash}">${shorten(hash, 12)}</a></td>
                    <td><a href="/address/hash/${miner}">${shorten(miner, 25)}</a></td>
                    <td><a href="/block/number/${number}/txs">${txCount}</a></td>
                    <td><a href="/block/number/${number}/mined">${uncleCount}</a></td>
                    <td></td>
                    </tr>`;
                }

                // TODO Open with id if forked block, with number if not

            }

            return tableContent;
        }
    }

    /* Block List View Declaration End */

    /* Block View Declaration Start */

    const MAX_INIT_BLOCK_LIST_ELEMENTS_PER_SIDE = 100;  // This can't be small enough to fit the biggest screen in the world
    const BLOCK_LIST_ELEMENTS_LOAD_N = 20;  // Maximum of this number of block list elements are added each time when scroll change is performed
    const BLOCK_LIST_BNSS_KEY = 'block_list';

    class ViewBlock extends View {

        constructor(key, value) {
            super();
            this.targetKey = key;
            this.targetValue = value;
            this.blocklistInner = null; // Div element which is is block-list-inner
            this.blocklist = null;      // Div element which id is block-list

            this.latestBlockNumber = null; // Latest block number known by the client
            this.blockListInitialized = false;
            this.scrollCheckIntervalId = null;  // setInterval id of scrollCheck calling
            this.scrollAction = false; // Not to do scroll change if events are issued while performing it
            this.elementHeight = -1; // Height of one block list element
            this.nextTopBlockNum = null;    // Next block number will be added to the block list on BEGINNING
            this.nextBottomBlockNum = null; // Next block number will be added to the block list on END including a working block
        }

        getTitle() {
            if (this.targetKey === 'number') {
                return `Block #${this.targetValue}`;
            } else if (this.targetKey === 'hash') {
                return `Block ${this.targetValue}`;
            }
        }

        open() {
            let content = [this.targetKey, this.targetValue];

            let self = this;

            requestService.connectAndRequest('block', content, function(response) {
                self.blockRequestCallback(response);
                loadingEnd();
            });
        }

        beforeClosing() {
            clearInterval(this.scrollCheckIntervalId);  // Remove scroll check in a interval
            blockNumberStreamService.removeListener(BLOCK_LIST_BNSS_KEY);   // Remove block number listener
        }

        blockRequestCallback(response) {
            if (response === false) {
                return;
            }

            let uncles_html = '';
            let transactions_html = '';

            let uncles = response['uncles'];
            for (let i in uncles) {
                uncles_html += `#${uncles[i][1]}<br>`;
            }

            let divided = new BigNumber(response['difficulty']);
            let humanReadableDiff;
            let prefixIndex = 0;

            while ((divided = divided.div(1000)).comparedTo(1) >= 0) {
                humanReadableDiff = divided;
                prefixIndex++;
            }

            let difficultyFormatted = humanReadableDiff.round(2).toString() + DIFF_PREFIXES[prefixIndex];
            let timestampFormatted = formatUTCUnixEpoch(response['timestamp']);

            div_contents.innerHTML =
                `<div class="pure-g">
            <div id="blockview-left" class="pure-u-1-4">
                <div id="blockview-list">
                    <div id="blockview-list-inner">

                    </div>
                </div>
            </div>
            <div class="pure-u-3-4">
                <div id="blockview-right">
                    <h1>Block #${response['number']}</h1>
                    <div >
                        <div class="block-time">
                            <canvas id="canvas-block-time-clock" class="block-time-clock"
                                title="${timestampFormatted}"
                                height="200px" width="200px"></canvas>
                        </div>
                        <div class="block-about">
                            <span class="mini-caption">Hash</span><span class="captioned-text">${response['hash']}</span>
                            <span class="mini-caption">Miner</span><span class="captioned-text"></span>
                            <span class="mini-caption">Difficulty</span><span class="captioned-text" title="${response['difficulty']}">${difficultyFormatted}</span>
                            <span class="mini-caption">Gas</span>
                            <span class="captioned-text">
                            <span title="The amount of gas used in this block">${response['gas_used']}</span> / <span title="The upper limit of gas could be used in this block">${response['gas_limit']}</span>
                            </span>
                            <span class="mini-caption">Extra Data</span><span class="captioned-text">${response['extra_data']}</span>
                            <span class="mini-caption">Nonce</span><span class="captioned-text">${response['nonce']}</span>
                            <span class="mini-caption">Size</span><span class="captioned-text">${response['size']} bytes</span>
                            <span class="mini-caption">Internal Id</span><span class="captioned-text">${response['internal_id']}</span>
                        </div>
                    </div>
                    <h2><a onclick="">Transaction(s)</a></h2>
                    <div>
                        <h2>${response['uncles'].length} Uncle(s)</h2>

                        ${uncles_html}
                    </div>
                </div>
            </div>
        </div>`;

            let cc = document.getElementById('canvas-block-time-clock').getContext('2d');
            drawClock(cc, response['timestamp']);

            this.blocklistInner = document.getElementById('blockview-list-inner');
            this.blocklist = document.getElementById('blockview-list');

            let self = this;

            this.blocklist.addEventListener('scroll', function () {
                self.scrollEvent(); // Functions in class doesn't have real 'value' have to call them from a function
            });  // Add event listener for block list scroll event

            this.scrollCheckIntervalId = setInterval(function () {
                console.log("called");
                self.scrollEvent();
            }, 1000);   // This is for up scroll glitch not for ie fail-safe

            blockNumberStreamService.registerListener(BLOCK_LIST_BNSS_KEY, function (blockNumber) {    // Register listener for real-time block list update
                let beforeLatestBlockNumber = self.latestBlockNumber;
                self.latestBlockNumber = new BigNumber(blockNumber);

                if (beforeLatestBlockNumber === null) {   // If this was the first message
                    /* Initialize block list */

                    self.fillBlockList(new BigNumber(response['number']));

                    self.blockListInitialized = true;    // Block list successfully initialized, now scroll event will be performed
                } else {
                    if (self.latestBlockNumber.comparedTo(beforeLatestBlockNumber) < 0) {
                        /* Block chain reorganization happened (forking) */

                        self.nextBottomBlockNum = self.latestBlockNumber.add(1);
                        let i = self.nextBottomBlockNum;

                        /* Removing list elements who got deleted from the blockchain */
                        while (i.comparedTo(beforeLatestBlockNumber) <= 0) {
                            let rmv = document.getElementById('blockview-list-element-n' + i);
                            rmv.parentNode.removeChild(rmv);
                        }
                    } else {

                        if (self.nextBottomBlockNum.comparedTo(beforeLatestBlockNumber.add(1)) === 0) {  // Latest block are shown
//                let scrollBottom = blocklist.scrollTop === (blocklistInner.clientHeight - blocklist.clientHeight);

                            self.addToBlockList('beforeEnd', self.nextBottomBlockNum);
                            self.nextBottomBlockNum = self.nextBottomBlockNum.add(1);

//                if (scrollBottom) { // If scroll was max, set max again
//                    blocklist.scrollTop = blocklistInner.clientHeight - blocklist.clientHeight;
//                }
                        }
                    }
                }
            });
        }

        scrollEvent() {  // Add scroll event listener
            if (this.blockListInitialized && !this.scrollAction) {
//            scrollAction = true;

                if (this.blocklist.scrollTop <= this.elementHeight) {
                    /* Add more block elements on top of the list */
                    let i;

                    for (i = 0; i < BLOCK_LIST_ELEMENTS_LOAD_N; i++) {
                        if (this.nextTopBlockNum.comparedTo(0) < 0) {  // Already showing the oldest block (#0)
                            break;  // Don't add elements anymore
                        }
                        this.addToBlockList('afterBegin', this.nextTopBlockNum);   // Add an element on top of the list
                        this.nextTopBlockNum = this.nextTopBlockNum.sub(1);
                    }

                    if (i !== 0) {  // If elements are added
                        this.blocklist.scrollTop = this.elementHeight * (i + 1);  // Set scroll position to where it was, for interval execution
                    }
                } else if (this.blocklist.scrollTop >= this.blocklistInner.clientHeight - this.blocklist.clientHeight - this.elementHeight) {
                    /* Add more block elements on bottom of the list */
                    for (let i = 0; i < BLOCK_LIST_ELEMENTS_LOAD_N; i++) {
                        if (this.nextBottomBlockNum.comparedTo(this.latestBlockNumber.add(1)) > 0) {  // Already showing the latest block + 1
                            break;
                        }

                        this.addToBlockList('beforeEnd', this.nextBottomBlockNum);    // Add an element on bottom of the list
                        this.nextBottomBlockNum = this.nextBottomBlockNum.add(1);
                    }
                }

                this.scrollAction = false;
            }
        }

        fillBlockList(blockNumber) {
            this.blocklistInner.innerHTML = '';  // Clear all elements

            /* Fill block list with initial elements around the blockNumber */

            this.addToBlockList('beforeEnd', blockNumber);  // Add a center block

            this.elementHeight = this.blocklistInner.clientHeight; // Get how much y-space is needed for just one element

            this.nextTopBlockNum = blockNumber.sub(1);      // Next block number listed BEFORE the center block
            this.nextBottomBlockNum = blockNumber.add(1);   // Next block number listed AFTER the center block

            let topBlocks = Math.ceil(this.blocklist.clientHeight / this.elementHeight) + 1;  // Default value of the amount of elements listed before the center block.
            // Total height should be one element's height higher from the same as the list div height, if this number of elements are stacked

            if (topBlocks > MAX_INIT_BLOCK_LIST_ELEMENTS_PER_SIDE) {    // This stops infinite loop to happen if something went wrong
                topBlocks = MAX_INIT_BLOCK_LIST_ELEMENTS_PER_SIDE;
            }

            let bottomBlocks = topBlocks;   // Both default amount of bottom and top blocks are the same

            if (blockNumber.sub(topBlocks).comparedTo(0) < 0) {  // Check if this exceeds the lower limit of zero (minimum block number)
                topBlocks = blockNumber;    // Think blockNumber as the amount of blocks remaining on top of the center block.
                // This would list all elements from zero to before the center block
            }

            if (blockNumber.add(bottomBlocks).comparedTo(this.latestBlockNumber.add(1)) > 0) {  // Check if this exceeds the upper limit of latest block number + 1
                bottomBlocks = (this.latestBlockNumber.add(1)).sub(blockNumber).toNumber();
            }

            /* Most fun part! Add elements to the HTML */

            for (let i = 0; i < topBlocks; i++) {
                this.addToBlockList('afterBegin', this.nextTopBlockNum);    // Add element before the center block, watch out for decrement
                this.nextTopBlockNum = this.nextTopBlockNum.sub(1);
            }

            for (let i = 0; i < bottomBlocks; i++) {   // Add predecessors of the block
                this.addToBlockList('beforeEnd', this.nextBottomBlockNum);
                this.nextBottomBlockNum = this.nextBottomBlockNum.add(1);
            }

            /* Try to set scroll bar where the center block become center of the list */

            let yscroll = Math.round(this.elementHeight * (topBlocks + 0.5) - this.blocklist.clientHeight / 2);
            let yscrollMax = this.blocklistInner.clientHeight - this.blocklist.clientHeight;

            yscroll = Math.max(0, Math.min(yscroll, yscrollMax));   // Cannot scroll to negative or outside from an box

            this.blocklist.scrollTop = yscroll;  // Set scroll bar
        }

        addToBlockList(position, blockNumber) {
            this.blocklistInner.insertAdjacentHTML(position, `<span id="blockview-list-element-n${blockNumber}" class="blockview-list-element">${blockNumber}</span>`);
        }
    }

    /* Block View Declaration End */

    /* Address View Declaration Start */

    const ADDRESS_TYPE = {
        NORMAL: 'NORMAL',
        CONTRACT: 'CONTRACT'
    };

    class ViewAddress extends View {

        constructor(key, value) {
            super();
            this.targetKey = key;
            this.targetValue = value;
        }

        getTitle() {
            return `Address ${this.targetValue}`;
        }

        open() {
            requestService.connectAndRequest('address', [this.targetKey, this.targetValue], (content) => {
                if (content === false) {
                    // Address was not recorded on the server
                    div_contents.innerHTML = '<h1>Address did not found</h1>';
                    loadingEnd();
                    return;
                }

                // Human readability and something
                const internalId = content[0];
                const addr_hash = content[1];
                const addr_type = content[2];
                const alias = content[3];
                const description = content[4];
                const txs_count = content[5];
                const mined_count = content[6];
                const first_appear_block = content[7];
                const first_appear_ts = content[8];
                const last_appear_block = content[9];
                const last_appear_ts = content[10];

                // Mouse over hint for 'address type'
                let addr_type_title;

                if (addr_type === ADDRESS_TYPE.NORMAL) {
                    addr_type_title = 'Normal addresses are the wallets which have a public and private key pair';
                } else if (addr_type === ADDRESS_TYPE.CONTRACT) {
                    addr_type_title = 'Contract addresses are individual addresses generated for each contract when it is created';
                } else throw new Error('Unknown address type');

                // If alias was not registered (null) then remove section
                let alias_HTML;

                if (alias === null) {
                    alias_HTML = '';
                } else {
                    alias_HTML = `<h2 title="Registered alias of this address">${alias}<i class="fa fa-check-circle reviewed-admin-icon" aria-hidden="true" title="Reviewed by admins"></i></h2>`;
                }

                // Same here
                let description_HTML;

                if (description === null) {
                    description_HTML = '';
                } else {
                    description_HTML = `<p title="Registered description for this address">${description}</p>`;
                }

                // Write it to content div
                div_contents.innerHTML = `<div id="address-wrapper">
            <canvas id="address-icon" title="This address's portrait icon (nealy unique)"></canvas>
            <div id="address-info">
                <h1><span class="box-highlighted bh-green" title="${addr_type_title}">${addr_type}</span> Address <span id="address-hash">${addr_hash}</span></h1>
                ${alias_HTML}
                ${description_HTML}
                <p id="address-tags">Tags: <span class="address-tag">?</span></p>
                <h2><a href="/address/${this.targetKey}/${this.targetValue}/txs">${txs_count} transactions involved</a></h2>
                <h2><a href="/address/${this.targetKey}/${this.targetValue}/mined">${mined_count} blocks/uncles mined</a></h2>
                <h2>Last activity at <a href="/block/number/${last_appear_block}" title="Block #${last_appear_block}"> ${formatUTCUnixEpoch(last_appear_ts)}</a> (${humanizeUnixEpochDiffFromNow(last_appear_ts)})</h2>
                <h2>First appearance at <a href="/block/number/${first_appear_block}" title="Block #${first_appear_block}"> ${formatUTCUnixEpoch(first_appear_ts)}</a> (${humanizeUnixEpochDiffFromNow(first_appear_ts)})</h2>
            </div>
        </div>`;

                // Render address icon
                const option = {
                    seed:addr_hash,
                    size: 8,
                    scale: 16
                };
                blockies.render(option, document.getElementById('address-icon'));

                // Add anchor event
                addAllAnchorsEvent(div_contents);

                loadingEnd();
            });


        }
    }

    /* Address View Declaration End */

    /* Initialization Start */

    // Add inner link event for menu and title
    addAllAnchorsEvent(document.getElementsByTagName('header')[0]);

    transitView(location.pathname, false);
</script>

<footer>
<div class="pure-g">
<div class="pure-u-1-1">
    2017-2018 Made with ‚ù§ by Cupmouse <a href="https://twitter.com/Cupnmouse" target="_blank"><i style="color: #1da1f2" class="fa fa-twitter" aria-hidden="true"></i></a><br>
    <!-- Just kidding, who the hell loves code. Is it kind of a weird fetish? -->
</div>
</div>
</footer>
</body>
</html>